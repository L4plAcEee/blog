<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>学习周报W08 | L4plAce</title><meta name="author" content="L4plAce"><meta name="copyright" content="L4plAce"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Intro总结每日算法这周一共写了八道 递归&#x2F;递推&#x2F;回溯 题单里的题，感觉对回溯和DP的理解更深了。DP实际上就是对情况的枚举和记录，如何规划情况和情况的转移，则是解题关键。一般来说，先写递归，然后从递归把思路迁移至DP是最好的。当然，并不是所有回溯都能改写递归就是了。 算法通关系列背包dp-分组背包、完全背包分组背包，完全背包 和 0-1背包的关系 我认为是这样：0-1背包">
<meta property="og:type" content="article">
<meta property="og:title" content="学习周报W08">
<meta property="og:url" content="http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/index.html">
<meta property="og:site_name" content="L4plAce">
<meta property="og:description" content="Intro总结每日算法这周一共写了八道 递归&#x2F;递推&#x2F;回溯 题单里的题，感觉对回溯和DP的理解更深了。DP实际上就是对情况的枚举和记录，如何规划情况和情况的转移，则是解题关键。一般来说，先写递归，然后从递归把思路迁移至DP是最好的。当然，并不是所有回溯都能改写递归就是了。 算法通关系列背包dp-分组背包、完全背包分组背包，完全背包 和 0-1背包的关系 我认为是这样：0-1背包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.l4place.icu/img/avatar.jpg">
<meta property="article:published_time" content="2025-05-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-16T05:36:22.048Z">
<meta property="article:author" content="L4plAce">
<meta property="article:tag" content="入门">
<meta property="article:tag" content="总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.l4place.icu/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "学习周报W08",
  "url": "http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/",
  "image": "http://www.l4place.icu/img/avatar.jpg",
  "datePublished": "2025-05-12T16:00:00.000Z",
  "dateModified": "2025-05-16T05:36:22.048Z",
  "author": [
    {
      "@type": "Person",
      "name": "l4place",
      "url": "http://www.l4place.icu/blog.l4place.icu"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-pm3JLit8G2"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?39def90aa4d3003d2e4e8308e7a8c9f3";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-18VE0KD5YB"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-18VE0KD5YB')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-18VE0KD5YB', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "q81b5s7cx2");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"43KWPP3572","apiKey":"ee8951db0bf1102393ba02871176539f","indexName":"new_blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习周报W08',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F5F5DC;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 日志</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/CHANGELOG.html"><i class="fa-fw fas fa-cloud"></i><span> 站点日志</span></a></li><li><a class="site-page child" href="/talking.html"><i class="fa-fw fas fa-comments"></i><span> 技术杂谈</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/about.html"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/flink.html"><i class="fa-fw fas fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">L4plAce</span></a><a class="nav-page-title" href="/"><span class="site-name">学习周报W08</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 日志</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/CHANGELOG.html"><i class="fa-fw fas fa-cloud"></i><span> 站点日志</span></a></li><li><a class="site-page child" href="/talking.html"><i class="fa-fw fas fa-comments"></i><span> 技术杂谈</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/about.html"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/flink.html"><i class="fa-fw fas fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">学习周报W08</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-12T16:00:00.000Z" title="发表于 2025-05-13 00:00:00">2025-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-16T05:36:22.048Z" title="更新于 2025-05-16 13:36:22">2025-05-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;自上次更新已经过了&quot;,&quot;messageNext&quot;:&quot;天，文章内容可能过期了哦！&quot;,&quot;postUpdate&quot;:&quot;2025-05-16 13:36:22&quot;}" hidden></div><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="每日算法"><a href="#每日算法" class="headerlink" title="每日算法"></a>每日算法</h3><p>这周一共写了八道 递归&#x2F;递推&#x2F;回溯 题单里的题，<br>感觉对回溯和DP的理解更深了。<br>DP实际上就是对情况的枚举和记录，如何规划情况和情况的转移，<br>则是解题关键。<br>一般来说，先写递归，然后从递归把思路迁移至DP是最好的。<br>当然，并不是所有回溯都能改写递归就是了。</p>
<h3 id="算法通关系列"><a href="#算法通关系列" class="headerlink" title="算法通关系列"></a>算法通关系列</h3><h4 id="背包dp-分组背包、完全背包"><a href="#背包dp-分组背包、完全背包" class="headerlink" title="背包dp-分组背包、完全背包"></a>背包dp-分组背包、完全背包</h4><p>分组背包，完全背包 和 0-1背包的关系 我认为是这样：<br>0-1背包 -&gt; 分组背包 -&gt; 完全背包<br>是一个渐进的问题模型</p>
<p>本质上都是选择，而选择的不同体现在状态转移方程的不同：<br>0-1背包：</p>
<ol>
<li>$dp[i - 1][j]$</li>
<li>$dp[i - 1][j - cost[i]] + value[i], j - cost[i] &gt;&#x3D; 0$</li>
</ol>
<p>分组背包（其中i是组别）：<br>$dp[i - 1][j]$<br>或遍历组内物品：<br>同0-1背包 2公式</p>
<p>完全背包：</p>
<ol>
<li>$dp[i - 1][j]$</li>
<li>$dp[i][j - cost[i]] + value[i], j - cost[i] &gt;&#x3D; 0$</li>
</ol>
<hr>
<h1 id="背包dp-分组背包、完全背包-1"><a href="#背包dp-分组背包、完全背包-1" class="headerlink" title="背包dp-分组背包、完全背包"></a>背包dp-分组背包、完全背包</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UM411f7YL?vd_source=b235e9c478ba07e2678b1ac01bb439c6">【算法讲解074【必备】背包dp-分组背包、完全背包】</a></p>
</blockquote>
<p>前置知识:<br>讲解067、讲解068 - 二维动态规划及其空间压缩技巧<br>讲解073 - 01背包、有依赖的背包<br>【必备】课程的动态规划大专题从讲解066开始，建议从头开始学习会比较系统</p>
<p>分组背包：多个物品分组，每组只能取1件<br>        每一组的物品都可能性展开就可以了。注意时间复杂度不会升阶，O(物品数量 * 背包容量)</p>
<p>完全背包：与01背包的区别仅在于 每种商品可以选取无限次。时间复杂度O(物品数量 * 背包容量)</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="题目1-分组背包-模版"><a href="#题目1-分组背包-模版" class="headerlink" title="题目1 分组背包(模版)"></a>题目1 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1757">分组背包(模版)</a></h3><p>给定一个正数m表示背包的容量，有n个货物可供挑选<br>每个货物有自己的体积(容量消耗)、价值(获得收益)、组号(分组)<br>同一个组的物品只能挑选1件，所有挑选物品的体积总和不能超过背包容量<br>怎么挑选货物能达到价值最大，返回最大的价值</p>
<h4 id="解-0"><a href="#解-0" class="headerlink" title="解#0 &lt;-AC"></a>解#0 &lt;-AC</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXK 101</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, k = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN], nxt[MAXN], head[MAXK], dp[MAXK][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> res1 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="type">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> cur = head[i];</span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - w[cur] &gt;= <span class="number">0</span>) </span><br><span class="line">                    res2 = std::<span class="built_in">max</span>(res2, dp[i - <span class="number">1</span>][j - w[cur]] + v[cur]);</span><br><span class="line">                cur = nxt[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(nxt, <span class="number">0</span>, <span class="built_in">sizeof</span>(nxt));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> group;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; group;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp = head[group];</span><br><span class="line">        head[group] = i;</span><br><span class="line">        nxt[i] = temp;</span><br><span class="line">        </span><br><span class="line">        k = <span class="built_in">max</span>(k, group);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h4><p>您的代码存在几个关键错误：</p>
<ol>
<li><strong>变量未初始化</strong>：在 <code>main</code> 函数中，<code>temp</code> 变量在赋值给 <code>nxt[i]</code> 之前没有被初始化。</li>
<li><strong>不完整的语句</strong>：<code>head[group];</code> 这行代码没有任何操作，可能是想保存之前的值但忘记了。</li>
<li><strong>函数参数使用错误</strong>：在 <code>solve()</code> 函数中，有一行： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res2 = std::<span class="built_in">max</span>(res2, dp[i - <span class="number">1</span>][j - cur] + v[cur]);</span><br></pre></td></tr></table></figure>
 这里 <code>j - cur</code> 是不对的，应该使用 <code>j - w[cur]</code>，而且判断条件中已经使用了 <code>j - w[cur]</code>。</li>
<li><strong>循环参数不匹配</strong>：<code>solve()</code> 函数中使用了 <code>i = 1</code> 到 <code>k</code>，但返回 <code>dp[n][m]</code>，可能导致索引错误。</li>
<li><strong>变量使用混淆</strong>：在 <code>main</code> 函数中声明了 <code>a_i</code>, <code>b_i</code>, <code>c_i</code> 但没有使用。</li>
</ol>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li>数组模拟链表实现分组（记录头节点和每个节点的next）</li>
<li>分组背包思路，通过 模拟链表 遍历物品求出组内最优物品。</li>
</ol>
<h3 id="题目2-从栈中取出K个硬币的最大面值和"><a href="#题目2-从栈中取出K个硬币的最大面值和" class="headerlink" title="题目2 从栈中取出K个硬币的最大面值和"></a>题目2 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/">从栈中取出K个硬币的最大面值和</a></h3><p>一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币<br>每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里<br>给你一个列表 piles ，其中 piles<code>[i]</code> 是一个整数数组<br>分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k<br>请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少</p>
<h4 id="思路-0"><a href="#思路-0" class="headerlink" title="思路#0"></a>思路#0</h4><p>如何转化问题 -&gt; 分组背包？</p>
<ol>
<li>每个硬币栈的硬币，从顶至底，代价cost &#x3D;&#x3D; 从栈顶到该硬币的距离 + 1</li>
<li>每堆硬币都视为一组物品</li>
<li>在你取出底下的硬币的时候，必须先取出压在上面的硬币，所以 选择该硬币的收益 &#x3D;&#x3D;  从栈顶到该硬币的所有硬币面值和</li>
</ol>
<h5 id="Mistake"><a href="#Mistake" class="headerlink" title="Mistake"></a>Mistake</h5><p>❌ 代码逻辑错误点：<br>关键错误在于这行：<br><code>for (int coin = 0, cost = 1, sum = 0; coin &lt; piles[i].size(); ++coin, ++cost)</code></p>
<p>你在访问 <code>piles[i]</code>，但 <code>piles</code> 是 0-based，而你的 <code>i</code> 从 1 开始，这会导致 <strong>越界访问</strong>。正确的访问方式应该是：</p>
<p><code>piles[i - 1][coin]</code></p>
<h5 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueOfCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; piles, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> items = piles.<span class="built_in">size</span>() + <span class="number">1</span>, capacity = k + <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(items, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(capacity, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= piles.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> res1 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> res2 = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> coin = <span class="number">0</span>; coin &lt; piles[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; coin + <span class="number">1</span> &lt;= j; ++coin) &#123;</span><br><span class="line">                    sum += piles[i - <span class="number">1</span>][coin];</span><br><span class="line">                    res2 = <span class="built_in">max</span>(res2, dp[i - <span class="number">1</span>][j - (coin + <span class="number">1</span>)] + sum);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(res1, res2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[piles.<span class="built_in">size</span>()][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="优化"><a href="#优化" class="headerlink" title="优化 &lt;-空间压缩"></a>优化 &lt;-空间压缩</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueOfCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; piles, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">temp</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pile : piles) &#123;</span><br><span class="line">            temp = dp;  <span class="comment">// 只在这里进行一次拷贝</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; pile.<span class="built_in">size</span>() &amp;&amp; c + <span class="number">1</span> &lt;= j; ++c) &#123;</span><br><span class="line">                    sum += pile[c];</span><br><span class="line">                    temp[j] = <span class="built_in">max</span>(temp[j], dp[j - (c + <span class="number">1</span>)] + sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.<span class="built_in">swap</span>(temp);  <span class="comment">// 常数时间交换两个数组的指</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>dp[j]</code> 表示前若干堆中选择 <code>j</code> 个硬币的最大值。</li>
<li><code>new_dp</code> 保留更新后的一维状态，避免在当前迭代中覆盖前面的状态（这点非常关键）。</li>
<li>最终答案为 <code>dp[k]</code>。</li>
</ul>
<p>更进一步的优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValueOfCoins</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; piles, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pile : piles) &#123;</span><br><span class="line">            <span class="comment">// 对每一堆硬币，进行倒序更新，避免状态覆盖</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; pile.<span class="built_in">size</span>() &amp;&amp; c + <span class="number">1</span> &lt;= j; ++c) &#123;</span><br><span class="line">                    sum += pile[c];</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - (c + <span class="number">1</span>)] + sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="题目3-完全背包-模版"><a href="#题目3-完全背包-模版" class="headerlink" title="题目3 完全背包(模版)"></a>题目3 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">完全背包(模版)</a></h3><p>给定一个正数t，表示背包的容量<br>有m种货物，每种货物可以选择任意个<br>每种货物都有体积$costs[i]$和价值$values[i]$<br>返回在不超过总容量的情况下，怎么挑选货物能达到价值最大<br>返回最大的价值</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>dp[i][j]</code> 表示 1 ~ i 号 item 每种 item 可以无限选择，容量不超过 j 下的最大价值。<br>状态转移方程：<br>    1. <code>dp[i - 1][j]</code><br>    2. <code>dp[i][j - cost[i]] + value[i]</code></p>
<blockquote>
<p>这里的标号都是base-1的！</p>
</blockquote>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> i64 long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXT 10000001</span></span><br><span class="line"></span><br><span class="line">i64 t, m, dp[MAXT], c[MAXM], v[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(dp, dp + MAXT, <span class="number">0ll</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - c[i] &gt;= <span class="number">0</span>) dp[j] = std::<span class="built_in">max</span>(dp[j], dp[j - c[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目4-正则表达式匹配"><a href="#题目4-正则表达式匹配" class="headerlink" title="题目4 正则表达式匹配"></a>题目4 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></h3><p>给你字符串s、字符串p<br>s中一定不含有’.’、’<em>‘字符，p中可能含有’.’、’</em>‘字符<br>‘.’ 表示可以变成任意字符，数量1个<br>‘<em>‘ 表示可以让 ‘</em>‘ 前面那个字符数量任意(甚至可以是0个)<br>p中即便有’<em>‘，一定不会出现以’</em>‘开头的情况，也一定不会出现多个’<em>‘相邻的情况(无意义)<br>请实现一个支持 ‘.’ 和 ‘</em>‘ 的正则表达式匹配<br>返回p的整个字符串能不能匹配出s的整个字符串</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先写递归 -&gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f1</span><span class="params">(string &amp;s, string &amp;p, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == p.<span class="built_in">length</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> j + <span class="number">1</span> &lt; p.<span class="built_in">length</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">f1</span>(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.<span class="built_in">length</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> == p.<span class="built_in">length</span>() || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">bool</span> p1 = <span class="built_in">f1</span>(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">			<span class="type">bool</span> p2 = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j);</span><br><span class="line">			<span class="keyword">return</span> p1 || p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先分析可变参数：<br>i &lt;- 当前来到s字符串的索引<br>j &lt;- 当前来到p字符串的索引</p>
<p>而f(i, j)的含义是：s的子串<code>sub_s[i, s.len)</code> 和 p的子串<code>sub_p[j, p.len)</code>是否匹配</p>
<p>basecase：<br>当 i 来到s末尾时：<br>    如果p也到了末尾 则能匹配上（空串匹配空串），<br>    否则如果p是形如<code>a*b*c*</code>的串，则也能匹配上。<br>当 j 来到p末尾时：<br>    如果s没到末尾，则不能匹配上。</p>
<p>状态转移：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> == p.<span class="built_in">length</span>() || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">bool</span> p1 = <span class="built_in">f1</span>(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">	<span class="type">bool</span> p2 = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j);</span><br><span class="line">	<span class="keyword">return</span> p1 || p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-&gt; 优化到memorize dfs</strong></p>
<p>前面已经提到了问题状态只由可变参数 i 和 j 决定<br>所以建立一个二维表dp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f2</span><span class="params">(string &amp;s, string &amp;p, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;dp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == p.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> j + <span class="number">1</span> &lt; p.<span class="built_in">length</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">f2</span>(s, p, i, j + <span class="number">2</span>, dp);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (dp[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> (<span class="type">bool</span>)dp[i][j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (j + <span class="number">1</span> == p.<span class="built_in">length</span>() || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">		dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f2</span>(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>, dp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">bool</span> p1 = <span class="built_in">f2</span>(s, p, i, j + <span class="number">2</span>, dp);</span><br><span class="line">		<span class="type">bool</span> p2 = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; <span class="built_in">f2</span>(s, p, i + <span class="number">1</span>, j, dp);</span><br><span class="line">		dp[i][j] = p1 || p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">bool</span>)dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>-&gt; 优化到动态规划</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">length</span>(), m = p.<span class="built_in">length</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">	dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">		dp[n][j] = j + <span class="number">1</span> &lt; m &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j + <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> == m || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">				dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				dp[i][j] = dp[i][j + <span class="number">2</span>] || ((s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h3 id="题目5-通配符匹配"><a href="#题目5-通配符匹配" class="headerlink" title="题目5 通配符匹配"></a>题目5 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wildcard-matching/">通配符匹配</a></h3><p>给你字符串s、字符串p<br>s中一定不含有’?’、’<em>‘字符，p中可能含有’?’、’</em>‘字符<br>‘?’ 表示可以变成任意字符，数量1个<br>‘<em>‘ 表示可以匹配任何字符串<br>请实现一个支持 ‘?’ 和 ‘</em>‘ 的通配符匹配<br>返回p的整个字符串能不能匹配出s的整个字符串</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>同 题目4<br>先写递归</p>
<p>basecase：<br>当 i 来到s末尾时：<br>    如果p也到了末尾 则能匹配上（空串匹配空串），<br>    否则如果p是形如<code>*...*</code>的串，则也能匹配上。<br>当 j 来到p末尾时：<br>    如果s没到末尾，则不能匹配上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f1</span><span class="params">(string &amp;s, string &amp;p, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == p.<span class="built_in">length</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">f1</span>(s, p, i, j + <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.<span class="built_in">length</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j) || <span class="built_in">f1</span>(s, p, i, j + <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; <span class="built_in">f1</span>(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接跳到dp -&gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">length</span>(), m = p.<span class="built_in">length</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">	dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">		dp[n][j] = p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">				dp[i][j] = dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="题目6-购买足量干草的最小花费"><a href="#题目6-购买足量干草的最小花费" class="headerlink" title="题目6 购买足量干草的最小花费"></a>题目6 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2918">购买足量干草的最小花费</a></h3><p>有n个提供干草的公司，每个公司都有两个信息<br>$cost[i]$代表购买1次产品需要花的钱<br>$val[i]$代表购买1次产品所获得的干草数量<br>每个公司的产品都可以购买任意次<br>你一定要至少购买h数量的干草，返回最少要花多少钱</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><code>dp[i][j]</code> 表示 1 ~ i 号 item 每种 item 可以无限选择，容量不超过 j 下的最小开销。<br>状态转移方程：<br>    1. <code>dp[i - 1][j]</code><br>    2. <code>dp[i][j - value[i]] + cost[i]</code></p>
<blockquote>
<p>这里的标号都是base-1的！</p>
</blockquote>
<h5 id="自己的版本"><a href="#自己的版本" class="headerlink" title="自己的版本"></a>自己的版本</h5><blockquote>
<p>过了30%的点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i64 long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXH 50001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 101</span></span><br><span class="line"></span><br><span class="line">i64 H, N, c[MAXN] = &#123;<span class="number">0</span>&#125;, v[MAXN] = &#123;<span class="number">0</span>&#125;, dp[MAXN][MAXH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; H;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + MAXH, LONG_LONG_MAX);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= H; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - v[i]] != LONG_LONG_MAX)</span><br><span class="line">                dp[i][j] = std::<span class="built_in">min</span>(dp[i][j], dp[i][j - v[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i64 ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[j][H]);</span><br><span class="line">    &#125;</span><br><span class="line">   cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>少了扩容<br>h并不是最终的v<br>会有超过的地方</p>
<p>而这是最关键的地方</p>
<h4 id="正解版本"><a href="#正解版本" class="headerlink" title="正解版本"></a>正解版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i64 long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXH 60000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 101</span></span><br><span class="line"></span><br><span class="line">i64 H, N, c[MAXN] = &#123;<span class="number">0</span>&#125;, v[MAXN] = &#123;<span class="number">0</span>&#125;, dp[MAXN][MAXH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; H;</span><br><span class="line">    i64 h = H;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H += *<span class="built_in">max_element</span>(v, v + N + <span class="number">1</span>); <span class="comment">// 关键</span></span><br><span class="line">    std::<span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + MAXH, LONG_LONG_MAX);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= H; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - v[i]] != LONG_LONG_MAX)</span><br><span class="line">                dp[i][j] = std::<span class="built_in">min</span>(dp[i][j], dp[i][j - v[i]] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   cout &lt;&lt; *std::<span class="built_in">min_element</span>(dp[N] + h, dp[N] + H + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="每日算法-1"><a href="#每日算法-1" class="headerlink" title="每日算法"></a>每日算法</h1><h2 id="Daily-算法-P1036-NOIP-2002-普及组-选数"><a href="#Daily-算法-P1036-NOIP-2002-普及组-选数" class="headerlink" title="Daily::算法 @P1036 [NOIP 2002 普及组] 选数"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1036">P1036 [NOIP 2002 普及组] 选数</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知 n 个整数 x1​,x2​,⋯,xn​，以及 1 个整数 k（k&lt;n）。从 n 个整数中任选 k 个整数相加，可分别得到一系列的和。例如当 n&#x3D;4，k&#x3D;3，4 个整数分别为 3,7,12,19 时，可得全部的组合与它们的和为：</p>
<p>3+7+12&#x3D;22</p>
<p>3+7+19&#x3D;29</p>
<p>7+12+19&#x3D;38</p>
<p>3+12+19&#x3D;34</p>
<p>现在，要求你计算出和为素数共有多少种。<br>例如上例，只有一种的和为素数：3+7+19&#x3D;29。</p>
<h3 id="思路-0-1"><a href="#思路-0-1" class="headerlink" title="思路#0 &lt;-AC"></a>思路#0 &lt;-AC</h3><p>&lt;深度优先搜索&gt; + &lt;素数判断&gt;<br>基本思路就是dfs硬搜，然后再验证答案是否素数？<br>但是能剪枝吗？<br>还有就是验证素数能优化吗？<br>素数筛？</p>
<h4 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h4><h5 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 21</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> idx, <span class="type">long</span> <span class="type">long</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">is_prime</span>(sum) ? <span class="number">1</span> : <span class="number">0</span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, idx + <span class="number">1</span>, sum + a[idx]) + <span class="built_in">dfs</span>(cnt, idx + <span class="number">1</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> n = <span class="number">3</span>; n * n &lt;= num; n += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h5 id="问题一：DFS-能剪枝吗？"><a href="#问题一：DFS-能剪枝吗？" class="headerlink" title="问题一：DFS 能剪枝吗？"></a><strong>问题一：DFS 能剪枝吗？</strong></h5><p><strong>结论</strong>： <strong>剪枝空间很小，不建议额外加剪枝逻辑</strong>，因为：</p>
<ul>
<li>总体搜索空间为 $C_n^k$，最多 $C_{20}^{10} \approx 184,756$；</li>
<li>每个 DFS 只走深度为 $k$，计算量完全可接受；</li>
<li>常见剪枝（如提前判断 <code>sum</code> 是否超过某个上限）对“素数和”这个目标没帮助。</li>
</ul>
<h5 id="问题二：素数判断可以优化吗？"><a href="#问题二：素数判断可以优化吗？" class="headerlink" title="问题二：素数判断可以优化吗？"></a>问题二：素数判断可以优化吗？</h5><p>目前做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> n = <span class="number">3</span>; n * n &lt;= num; n += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (num % n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <strong>试除法判定素数</strong>，复杂度为 $O(\sqrt{N})$，考虑到数据范围较小，这在本题中已经足够。</p>
<p><strong>-&gt; 进一步优化方法：使用「素数筛」预处理 + 判定</strong><br>考虑到：</p>
<ul>
<li>每次组合的总和最大为 $k \times 5 \times 10^6 &#x3D; 10^8$；</li>
<li>预处理素数可以将判定降为 $O(1)$；</li>
<li>但内存需求约为 $10^8$ 位 ≈ 12.5MB，仍可接受。</li>
</ul>
<hr>
<h2 id="Daily-算法-P3612-USACO17JAN-Secret-Cow-Code-S"><a href="#Daily-算法-P3612-USACO17JAN-Secret-Cow-Code-S" class="headerlink" title="Daily::算法 @P3612 [USACO17JAN] Secret Cow Code S"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3612">P3612 [USACO17JAN] Secret Cow Code S</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>奶牛们正在实验秘密代码，并设计了一种方法用于生成无限长度的字符串，作为他们代码的一部分。</p>
<p>给定一个字符串 s，令 F(s) 为 s 后接 s 向右“旋转”一个字符的结果（在右旋转中，s 的最后一个字符旋转并成为新的第一个字符）。给定初始字符串 s，奶牛们通过重复应用 F 来构建他们的无限长度代码字符串；因此每一步都会使当前字符串的长度翻倍。</p>
<p>给定初始字符串和一个索引 N，请帮助奶牛计算无限代码字符串中第 N 个位置的字符。</p>
<blockquote>
<ol>
<li>请注意，N 可能太大，无法放入标准的 32 位整数中，因此你可能需要使用 64 位整数类型（例如，C&#x2F;C++ 中的 “long long”）。</li>
<li>在这个例子中，初始字符串 COW 按以下方式扩展：COW -&gt; COWWCO -&gt; COWWCOOCOWWC</li>
</ol>
</blockquote>
<h3 id="思路-0-2"><a href="#思路-0-2" class="headerlink" title="思路#0"></a>思路#0</h3><p>COW -&gt; COW + (WCO) -&gt; COWWCO + (OCOWWC)<br>实际上是多次调用 $F(s)$的 结果<br>问题的关键在于 第N个字符 在第几次调用？</p>
<blockquote>
<p>“奶牛们通过重复应用 F 来构建他们的无限长度代码字符串；因此每一步都会使当前字符串的长度翻倍。”</p>
</blockquote>
<p>可以通过记录字符串长度的方式获知在第几层递归？</p>
<p>不过要注意：绝对不可能是真的构造这么长的字符串的，放不下的。</p>
<p>我们分析每一层递归构造的字符串s的情况：<br>对于前半串 $s_f$ 和 后半串 $s_b$<br><img src="/img/assets/226188711511390fa4ddea692ea03b34_MD5.jpeg"></p>
<p>可以建立映射关系：<br>对于当前层的 <code>s[i]</code>(base-1) 和 l（s的长度） 而言<br>当 i &#x3D;&#x3D; l&#x2F;2 时 <code>s[l/2] == s[l/2 + 1]</code><br>当 1 &lt; i &lt; l&#x2F;2 时 <code>s[i] == s[l/2 + 1 + i]</code></p>
<p>当我们建立了映射关系之后，就可以将原本的索引 N 逐步缩小。</p>
<h4 id=""><a href="#" class="headerlink" title="&lt;递归&gt;"></a>&lt;递归&gt;</h4><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> i64 long long</span></span><br><span class="line">string s;</span><br><span class="line">i64 N;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">solve</span><span class="params">(i64 idx, i64 len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &lt;= s.<span class="built_in">length</span>()) <span class="keyword">return</span> idx;</span><br><span class="line">    i64 half = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (idx == half + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(half, half);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx &gt; half + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(idx - half - <span class="number">1</span>, half);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(idx, half);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; N;</span><br><span class="line">    i64 len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (len &lt; N) len *= <span class="number">2</span>;</span><br><span class="line">    i64 pos = <span class="built_in">solve</span>(N, len);</span><br><span class="line">    cout &lt;&lt; s[pos - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="压行"><a href="#压行" class="headerlink" title="压行"></a>压行</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">solve</span><span class="params">(i64 idx, i64 len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (idx &lt;= s.<span class="built_in">length</span>()) ? idx : ((idx == len / <span class="number">2</span> + <span class="number">1</span>) ? <span class="built_in">solve</span>(len / <span class="number">2</span>, len / <span class="number">2</span>) : ((idx &gt; len / <span class="number">2</span> + <span class="number">1</span>) ? <span class="built_in">solve</span>(idx - len / <span class="number">2</span> - <span class="number">1</span>, len / <span class="number">2</span>) : <span class="built_in">solve</span>(idx, len / <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Daily-算法-P1164-小A点菜"><a href="#Daily-算法-P1164-小A点菜" class="headerlink" title="Daily::算法 @P1164 小A点菜"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。</p>
<p>uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。</p>
<p>不过 uim 由于买了一些书，口袋里只剩 M 元 $(M≤10000)$。</p>
<p>餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N≤100)$，第 i 种卖 $a_i​$ 元 $(a_i​≤1000)$。由于是很低端的餐馆，所以每种菜只有一份。</p>
<p>小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。</p>
<p>由于小 A 肚子太饿，所以最多只能等待 1 秒。</p>
<h3 id="思路-0-3"><a href="#思路-0-3" class="headerlink" title="思路#0"></a>思路#0</h3><p><del>&lt;DP - 0-1背包问题模型&gt;</del><br><del>定义dp数组：<br>    <code>dp[i][j]</code> 为 在 花费 j 元 的情况下，选择前 i 个物品的最大点菜方法。<br>定义状态转移：<br>    1. 不选择第 i 个物品：<code>dp[i][j] = dp[i - 1][j]</code><br>    2. 选择第 i 个物品：<code>dp[i][j] = dp[i - 1][j - cost[i] + 1</code></del></p>
<p>&lt;DP - 变种0-1背包&gt;<br>典型的 <strong>0&#x2F;1 背包问题求“恰好凑出目标和的方案数”</strong> 的变种，<strong>但也实现错误</strong>，你返回的是“最多能选几道菜”，并非题目要求的“有多少种选菜方案”。</p>
<p>目标是：从 <code>N</code> 个数中，选若干个 <strong>互不相同</strong> 的数，使其和恰好为 <code>M</code>，问有多少种方案。<br>定义状态：<br>    <code>dp[i][j]</code> 表示前 <code>i</code> 个菜中，花费为 <code>j</code> 的选法数量。</p>
<p>递推公式：</p>
<ul>
<li>不选第 <code>i</code> 个菜：<code>dp[i][j] += dp[i-1][j]</code></li>
<li>选第 <code>i</code> 个菜（若 <code>j &gt;= cost[i]</code>）：<code>dp[i][j] += dp[i-1][j - cost[i]]</code></li>
</ul>
<h4 id="提交-0"><a href="#提交-0" class="headerlink" title="提交#0 &lt;-WA"></a>提交#0 &lt;-WA</h4><p>过了一个点，其他全WA了。<br>什么情况？<br>下个数据看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的输出：3</span><br><span class="line">正解：8</span><br></pre></td></tr></table></figure>
<p>dp定义错了？应该不是<br>应该是状态转移错了？</p>
<h3 id="提交-1"><a href="#提交-1" class="headerlink" title="提交#1 &lt;-AC"></a>提交#1 &lt;-AC</h3><h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><p><strong>普通版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 什么都不选，总价为 0 的方案为 1 种</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">		<span class="comment">// 不选第 i 个菜</span></span><br><span class="line">		dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">		<span class="comment">// 选第 i 个菜</span></span><br><span class="line">		<span class="keyword">if</span> (j &gt;= cost[i]) &#123;</span><br><span class="line">			dp[i][j] += dp[i - <span class="number">1</span>][j - cost[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间压缩</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = M; j &gt;= cost[i]; --j) &#123;</span><br><span class="line">		dp[j] += dp[j - cost[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h4><p>变种0-1背包别写成了经典0-1背包了</p>
<hr>
<h2 id="Daily-算法-P1928-外星密码"><a href="#Daily-算法-P1928-外星密码" class="headerlink" title="Daily::算法 @P1928 外星密码"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1928">P1928 外星密码</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 X 会压缩为 $[DX]$ 的形式（D 是一个整数且 1≤D≤99），比如说字符串 CBCBCBCB 就压缩为 $[4CB]$ 或者$[2[2CB]]$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $[2[2[2CB]]]$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。</p>
<h3 id="思路-0-4"><a href="#思路-0-4" class="headerlink" title="思路#0 &lt;递归&gt; &lt;-AC"></a>思路#0 &lt;递归&gt; &lt;-AC</h3><p>先用递归模拟流程</p>
<ol>
<li>遇到数字 -&gt; 积累轮数</li>
<li>遇到字母 -&gt; 构造串</li>
<li>遇到<code>[]</code> -&gt; 调用递归</li>
</ol>
<h4 id="Mistake-1"><a href="#Mistake-1" class="headerlink" title="Mistake"></a>Mistake</h4><ol>
<li><code>repeat * weight</code> 计算顺序反了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repeat = repeat * weight + (<span class="type">int</span>)(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">weight *= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
正确写法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat = repeat * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><code>i++</code> 在 <code>solve(s, i);</code> 调用前增加了作用域外的变量<br>在处理 <code>[</code> 和 <code>]</code> 时使用了 <code>i++</code>，这会导致 <code>for</code> 循环外的 <code>i</code> 不被更新到递归中<br><strong>问题在于：</strong> 递归后 <code>i</code> 其实应该由内部更新回来，不应该在调用前手动 <code>i++</code>。<br><strong>正确写法：</strong> 直接进入递归，循环中不要再 <code>i++</code>，而应改为使用 <code>while</code> 循环或将 <code>i</code> 控制从 <code>idx</code> 接手。</li>
</ol>
<p>正确写法：直接进入递归，循环中不要再 <code>i++</code>，而应改为使用 <code>while</code> 循环或将 <code>i</code> 控制从 <code>idx</code> 接手。<br>2. <code>return string(res, repeat);</code><br><code>string(res, repeat)</code> 实际是使用字符串构造的子串，而不是重复构造。<br>应该这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string tmp;</span><br><span class="line"><span class="keyword">while</span> (repeat--) tmp += res;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure>

<h4 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">solve</span><span class="params">(string &amp;s, <span class="type">int</span> &amp;idx)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> repeat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> cur = s[idx++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(cur)) &#123;</span><br><span class="line">            repeat = repeat * <span class="number">10</span> + (cur - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            res += <span class="built_in">solve</span>(s, idx);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(cur)) &#123;</span><br><span class="line">            res += cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            string temp = res;</span><br><span class="line">            <span class="keyword">while</span> (repeat &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += temp;</span><br><span class="line">                repeat--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h4><blockquote>
<p>在递归的层层嵌套中 厘清 当前来到的位置。</p>
</blockquote>
<p>这是处理递归解析类题目的核心思想，尤其是在需要携带上下文状态（如当前索引）的场景中，<strong>明确当前递归所处的“位置”以及其作用域内该做什么，是解题的关键</strong>。</p>
<p><strong>为什么这段代码有效？</strong><br>你的实现利用了一个巧妙的结构：</p>
<ul>
<li>每次进入 <code>solve</code>，会构造当前层级的字符串 <code>res</code>；</li>
<li>当遇到 <code>]</code>，说明当前层级的括号结束，此时将整个 <code>res</code> 重复 <code>repeat</code> 次（原本是 1 次，<code>repeat-1</code> 次追加）；</li>
<li>然后 <code>return</code> 给上一层递归。<br>虽然重复操作在 <code>]</code> 处处理，并不是在 <code>[</code> 之后立刻处理，但由于你递归层级对应得非常清晰，<strong>嵌套结构下不会错位</strong>，因此也能得到正确的结果。</li>
</ul>
<h4 id="可能的优化"><a href="#可能的优化" class="headerlink" title="可能的优化 &lt;显式栈&gt;"></a>可能的优化 &lt;显式栈&gt;</h4><p>这题用递归做是因为题目保证最大解压深度（即递归深度）不超过十层，所以普通递归就不会爆栈帧空间。<br>这是一个“<strong>软约束</strong>”支撑下的简洁递归实现，但它的本质依然是<strong>深度优先解析嵌套结构</strong>。这在多数平台 AC 是没有问题的。<br>如果递归层数深了，可能就要用栈模拟递归行为（显式栈）了。</p>
<h6 id="显式栈思路："><a href="#显式栈思路：" class="headerlink" title="显式栈思路："></a>显式栈思路：</h6><p>我们可以维护两个栈：</p>
<ol>
<li><strong>字符串栈</strong> <code>resStack</code>：保存每一层返回前的 <code>res</code>；</li>
<li><strong>数字栈</strong> <code>repeatStack</code>：保存每一层的 <code>repeat</code>；</li>
</ol>
<h5 id="模拟过程："><a href="#模拟过程：" class="headerlink" title="模拟过程："></a>模拟过程：</h5><ul>
<li>遇到数字 → 构造 <code>repeat</code>;</li>
<li>遇到 <code>[</code> → 压栈当前 <code>res</code> 和 <code>repeat</code>，重置当前 <code>res</code>;</li>
<li>遇到 <code>]</code> → 弹出 <code>repeat</code> 和上层 <code>res</code>，拼接多次后合并；</li>
<li>遇到字母 → 当前 <code>res += ch</code>。</li>
</ul>
<h2 id="Daily-算法-P2437-蜜蜂路线"><a href="#Daily-算法-P2437-蜜蜂路线" class="headerlink" title="Daily::算法 @P2437 蜜蜂路线"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2437">P2437 蜜蜂路线</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房 m 开始爬到蜂房 n，m&lt;n，有多少种爬行路线？（备注：题面有误，右上角应为 n−1）</p>
<p><img src="/img/assets/67fff3cca63c3ab33463ed7b9834095b_MD5.webp"></p>
<h3 id="思路-0-5"><a href="#思路-0-5" class="headerlink" title="思路#0"></a>思路#0</h3><blockquote>
<p><memorize_dfs> &lt;-40pt.</p>
</blockquote>
<p>类似 斐波那契数列 ，直接记忆化搜索尝试。<br>过不了是因为数字太大了，需要高精度加法。</p>
<h4 id="关键代码-3"><a href="#关键代码-3" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">memorize_dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i] = <span class="built_in">memorize_dfs</span>(i - <span class="number">1</span>) + <span class="built_in">memorize_dfs</span>(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路#1"></a>思路#1</h3><blockquote>
<p>&lt;memorize_dfs + 高精度加法&gt; &lt;-AC</p>
</blockquote>
<h4 id="关键代码-4"><a href="#关键代码-4" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str_add</span><span class="params">(string <span class="type">const</span> &amp;a, string <span class="type">const</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    string ret = <span class="built_in">string</span>(<span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()) + <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>, j = b.<span class="built_in">length</span>() - <span class="number">1</span>, k = ret.<span class="built_in">length</span>() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="type">int</span> x = (i &gt;= <span class="number">0</span> ? a[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> y = (j &gt;= <span class="number">0</span> ? b[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        ret[k--] = <span class="string">&#x27;0&#x27;</span> + (sum % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) ret.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Mistake-2"><a href="#Mistake-2" class="headerlink" title="Mistake"></a>Mistake</h4><ol>
<li><strong>未处理 i 或 j 尚未遍历完的情况</strong><br> 如果 <code>a</code> 和 <code>b</code> 长度不等，只处理了 <code>i &gt;= 0 &amp;&amp; j &gt;= 0</code> 的交集，未处理剩余的部分。</li>
<li><strong>进位处理不完整（k&#x3D;0 的时候）</strong><br> 当最高位有进位（如 999 + 1 &#x3D; 1000），<code>ret[0]</code> 会是有效的 <code>&#39;1&#39;</code>，否则就是 <code>&#39;0&#39;</code>。但你在：<br> <code>ret[k] = &#39;0&#39; + carry;</code><br> 只写了一位，而没有处理后续进位（如果 carry &#x3D;&#x3D; 1 且 k &#x3D;&#x3D; 0，可能仍有问题）。</li>
<li><strong>删除前导零可能导致空字符串</strong><br> 如果结果是 <code>&quot;0&quot;</code>（比如 <code>a = &quot;0&quot;, b = &quot;0&quot;</code>），你会删成空字符串，造成不合法的返回值。</li>
</ol>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路#2"></a>思路#2</h3><blockquote>
<p>&lt;空间压缩DP + 高精加&gt; &lt;-AC</p>
</blockquote>
<h4 id="关键代码-5"><a href="#关键代码-5" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    string pre1 = <span class="string">&quot;1&quot;</span>, pre2 = <span class="string">&quot;0&quot;</span>, cur = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n) <span class="keyword">return</span> pre2;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> == n) <span class="keyword">return</span> pre1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx = i + <span class="number">1</span>; idx &lt;= n; ++idx) &#123;</span><br><span class="line">        cur = <span class="built_in">str_add</span>(pre1, pre2);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Daily-算法-P1464-Function"><a href="#Daily-算法-P1464-Function" class="headerlink" title="Daily::算法 @P1464 Function"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1464">P1464 Function</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个递归函数 w(a,b,c)</p>
<ul>
<li>如果 a≤0 或 b≤0 或 c≤0 就返回值 1。</li>
<li>如果 a&gt;20 或 b&gt;20 或 c&gt;20 就返回 w(20,20,20)</li>
<li>如果 a&lt;b 并且 b&lt;c 就返回 w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)。</li>
<li>其它的情况就返回 w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)</li>
</ul>
<p>这是个简单的递归函数，但实现起来可能会有些问题。当 a,b,c 均为 15 时，调用的次数将非常的多。你要想个办法才行。</p>
<p>注意：例如 w(30,−1,0) 又满足条件 1 又满足条件 2，请按照最上面的条件来算，答案为 1。</p>
<h3 id="思路-0-6"><a href="#思路-0-6" class="headerlink" title="思路#0 &lt;朴素DFS&gt;"></a>思路#0 &lt;朴素DFS&gt;</h3><p>直接按照题目要求写，尝尝咸淡。<br>时间复杂度那肯定是爆炸的，只是尝试格式过关就行。</p>
<h4 id="关键代码-6"><a href="#关键代码-6" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">w</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c&lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">20</span> || b &gt; <span class="number">20</span> || c &gt; <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">w</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c) <span class="keyword">return</span> <span class="built_in">w</span>(a, b, c - <span class="number">1</span>) + <span class="built_in">w</span>(a, b - <span class="number">1</span>, c - <span class="number">1</span>) - <span class="built_in">w</span>(a, b - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">w</span>(a - <span class="number">1</span>, b , c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b, c - <span class="number">1</span>) - <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路-1-1"><a href="#思路-1-1" class="headerlink" title="思路#1 &lt;记忆化DFS&gt; &lt;-AC"></a>思路#1 &lt;记忆化DFS&gt; &lt;-AC</h3><p>普通dfs肯定爆炸，题目也明确要求我们优化</p>
<blockquote>
<p>这是个简单的递归函数，但实现起来可能会有些问题。当 a,b,c 均为 15 时，调用的次数将非常的多。你要想个办法才行。</p>
</blockquote>
<p>注意到：</p>
<blockquote>
<p>如果 a&gt;20 或 b&gt;20 或 c&gt;20 就返回 w(20,20,20）</p>
</blockquote>
<p>所以开 21 的 三维数组辅助就够了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> memo[MAXN][MAXN][MAXN] = &#123;<span class="number">-1</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Mistake-3"><a href="#Mistake-3" class="headerlink" title="Mistake"></a>Mistake</h4><h5 id="1-函数调用错误"><a href="#1-函数调用错误" class="headerlink" title="1. 函数调用错误"></a>1. 函数调用错误</h5><p>在你定义的 <code>w2()</code> 中，函数体内部调用的是 <code>w(...)</code> 而不是 <code>w2(...)</code>，例如：<br><code>return w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);</code></p>
<blockquote>
<p>复制过来忘记改了md</p>
</blockquote>
<h5 id="2-初始化方式错误"><a href="#2-初始化方式错误" class="headerlink" title="2. 初始化方式错误"></a>2. 初始化方式错误</h5><p><code>int memo[MAXN][MAXN][MAXN] = &#123;-1&#125;;</code></p>
<p>这个初始化语法只会将 <code>memo[0][0][0] = -1</code>，其余其余元素仍然是未定义值（未必是 -1）。正确初始化整个数组的方法如下：</p>
<ul>
<li>如果使用 C++，推荐使用 <code>memset</code>：<br>  <code>memset(memo, -1, sizeof(memo));</code></li>
<li>或者使用 <code>std::vector</code> 和构造函数初始化：<br>  <code>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; memo(MAXN, vector&lt;vector&lt;int&gt;&gt;(MAXN, vector&lt;int&gt;(MAXN, -1)));</code></li>
</ul>
<h4 id="关键代码-7"><a href="#关键代码-7" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">w2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">20</span> || b &gt; <span class="number">20</span> || c &gt; <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">w2</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (memo[a][b][c] != <span class="number">-1</span>) <span class="keyword">return</span> memo[a][b][c];</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c)</span><br><span class="line">        <span class="keyword">return</span> memo[a][b][c] = <span class="built_in">w2</span>(a, b, c - <span class="number">1</span>) + <span class="built_in">w2</span>(a, b - <span class="number">1</span>, c - <span class="number">1</span>) - <span class="built_in">w2</span>(a, b - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">return</span> memo[a][b][c] = <span class="built_in">w2</span>(a - <span class="number">1</span>, b, c) + <span class="built_in">w2</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c) + <span class="built_in">w2</span>(a - <span class="number">1</span>, b, c - <span class="number">1</span>) - <span class="built_in">w2</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h4><p>注意不要复制过来忘记改函数名了 ：-（<br>不然debug半天</p>
<h3 id="思路-2-1"><a href="#思路-2-1" class="headerlink" title="思路#2 &lt;动态规划&gt; &lt;-AC"></a>思路#2 &lt;动态规划&gt; &lt;-AC</h3><p>有了记忆化DFS解那肯定要想想DP嘛。<br>分析一下题目：<br>    状态决定参数：a， b， c<br>    BaseCase：当 a &lt;&#x3D; 0 || b &lt;&#x3D; 0 || C &lt;&#x3D; 0 时 返回 1<br>    约束：<br>        1. 如果 a&gt;20 || b&gt;20 || c&gt;20 时返回 w(20,20,20) （只是作为限制的约束）<br>        2. 如果 a&lt;b 并且 b&lt;c 就返回 w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)。<br>        3. 其它的情况就返回 w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)</p>
<p>即 每个状态 依赖<br><code>dp[i][j][k]</code><br>-&gt; <code>dp[a][b][c - 1] + dp[a][b - 1] - dp[a][b - 1][c]</code> (当 a&lt;b 并且 b&lt;c)<br>-&gt; <code>dp[a - 1][b][c] + dp[a - 1][b - 1][c] + dp[a - 1][b][c - 1] - dp[a - 1][b - 1][c - 1]</code>（Common Senses）</p>
<h4 id="关键代码-8"><a href="#关键代码-8" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp_table[MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MAXN; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; MAXN; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp_table[i][j][k] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                    dp_table[i][j][k] = dp_table[i][j][k - <span class="number">1</span>] + dp_table[i][j - <span class="number">1</span>][k - <span class="number">1</span>] - dp_table[i][j - <span class="number">1</span>][k];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp_table[i][j][k] = dp_table[i - <span class="number">1</span>][j][k]</span><br><span class="line">                                      + dp_table[i - <span class="number">1</span>][j - <span class="number">1</span>][k]</span><br><span class="line">                                      + dp_table[i - <span class="number">1</span>][j][k - <span class="number">1</span>]</span><br><span class="line">                                      - dp_table[i - <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Daily-算法-P1028-NOIP-2001-普及组-数的计算"><a href="#Daily-算法-P1028-NOIP-2001-普及组-数的计算" class="headerlink" title="Daily::算法 @P1028 [NOIP 2001 普及组] 数的计算"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1028">P1028 [NOIP 2001 普及组] 数的计算</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出正整数 n，要求按如下方式构造数列：</p>
<ol>
<li>只有一个数 n 的数列是一个合法的数列。</li>
<li>在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。</li>
</ol>
<p>请你求出，一共有多少个合法的数列。两个合法数列 a,b 不同当且仅当两数列长度不同或存在一个正整数 $i≤∣a∣$，使得 $a_i​&#x3D;b_i​$ 。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>题目规模：对于全部的测试点，保证 $1≤n≤10^3$ 。<br>应该就是动态规划了<br>先写dfs吧<br>dfs思路就直接按题目来即可<br>先用vector试试</p>
<h3 id="提交-0-1"><a href="#提交-0-1" class="headerlink" title="提交#0 &lt;-TLE"></a>提交#0 &lt;-TLE</h3><p>过了5个点<br>剩下所有点TLE<br>思路是对的，继续优化为 memorize_dfs</p>
<h4 id="关键代码-9"><a href="#关键代码-9" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function">i64 <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">back</span>() == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    i64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= path.<span class="built_in">back</span>() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ret += <span class="built_in">dfs</span>();</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提交-1-1"><a href="#提交-1-1" class="headerlink" title="提交#1 &lt;-AC"></a>提交#1 &lt;-AC</h3><h4 id="关键代码-10"><a href="#关键代码-10" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">memorize_dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (path<span class="number">2.</span><span class="built_in">back</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (memo.<span class="built_in">count</span>(path<span class="number">2.</span><span class="built_in">size</span>()) &amp;&amp; memo[path<span class="number">2.</span><span class="built_in">size</span>()].<span class="built_in">count</span>(path<span class="number">2.</span><span class="built_in">back</span>()))</span><br><span class="line">        <span class="keyword">return</span> memo[path<span class="number">2.</span><span class="built_in">size</span>()][path<span class="number">2.</span><span class="built_in">back</span>()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= path<span class="number">2.</span><span class="built_in">back</span>() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        path<span class="number">2.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">        ret += <span class="built_in">memorize_dfs</span>();</span><br><span class="line">        path<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    memo[path<span class="number">2.</span><span class="built_in">size</span>()][path<span class="number">2.</span><span class="built_in">back</span>()] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    path<span class="number">2.</span><span class="built_in">push_back</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">memorize_dfs</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; memo;</span><br></pre></td></tr></table></figure>
<p>用嵌套哈希表做缓存<br>递推公式：<br>$$<br>f(k, m) &#x3D;<br>\begin{cases}<br>1, &amp; m &#x3D; 1,\<br>1 + \displaystyle\sum_{i&#x3D;1}^{\lfloor m&#x2F;2\rfloor} f(k+1,,i), &amp; m &gt; 1.<br>\end{cases}<br>$$<br>时间复杂度：<br>$$<br>T_{\rm dfs}(n)<br>&#x3D;1 + \sum_{i&#x3D;1}^{\lfloor n&#x2F;2\rfloor} T_{\rm dfs}(i),<br>$$<br>$$<br>T_{\rm memo}(n)<br>&#x3D;O\bigl(n\log n\bigr)\times O(n)<br>&#x3D;O\bigl(n^2\log n\bigr).<br>$$</p>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>在这个记忆化 DFS 的问题中，<strong>真正决定子问题状态的变量其实只有两个</strong>：</p>
<ol>
<li>当前递归的深度（或称 <code>idx</code>、<code>step</code>、<code>position</code>），</li>
<li>当前路径最后一个数（称为 <code>last</code> 或 <code>tail</code>），</li>
</ol>
<p>而栈（容器） <code>path</code> &#x2F; <code>path2</code> 的作用其实只是为了记录路径以供 debug 或打印用，在记忆化搜索中<strong>并不参与状态判断</strong>。</p>
<p>使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, i64&gt;&gt; memo;</span><br><span class="line"><span class="comment">// 或 unordered_map&lt;pair&lt;int, int&gt;, i64, custom_hash&gt; 更标准</span></span><br></pre></td></tr></table></figure>

<p>递归函数形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">dfs</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[idx][last]) <span class="keyword">return</span> memo[idx][last];</span><br><span class="line">    </span><br><span class="line">    i64 res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= last / <span class="number">2</span>; ++i)</span><br><span class="line">        res += <span class="built_in">dfs</span>(idx + <span class="number">1</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[idx][last] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正解：动态规划"><a href="#正解：动态规划" class="headerlink" title="正解：动态规划"></a>正解：动态规划</h3><h4 id="关键点-6"><a href="#关键点-6" class="headerlink" title="关键点"></a>关键点</h4><p>定义状态：</p>
<ul>
<li><code>dp[i][j]</code> 表示长度为 <code>i</code> 的序列，以 <code>j</code> 结尾的所有合法递减拆分方案数</li>
<li>状态定义：<code>dp[j]</code> 表示以 <code>j</code> 开头的合法拆分序列数量（以 1 结尾），即当前“尾数”为 <code>j</code> 时的所有后续方案数；</li>
<li>转移方式：从 <code>j</code> 可以转移到所有 <code>i</code> 满足 ，即 <code>dp[j] = 1 + sum(dp[i])</code> for all <code>i ≤ j/2</code>。</li>
</ul>
<h4 id="关键代码-11"><a href="#关键代码-11" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 底部递归边界：以1为结尾，只有一种（自己）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        dp[j] = <span class="number">1</span>; <span class="comment">// 自己组成一个序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= j / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            dp[j] += dp[i]; <span class="comment">// j -&gt; i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 以 n 开始的合法序列总数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Daily-算法-P1044-NOIP-2003-普及组-栈"><a href="#Daily-算法-P1044-NOIP-2003-普及组-栈" class="headerlink" title="Daily::算法 @P1044 [NOIP 2003 普及组] 栈"></a>Daily::算法 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1044">P1044 [NOIP 2003 普及组] 栈</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。</p>
<p>栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。</p>
<p>栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。</p>
<p><img src="/img/assets/29f439c4a73718eb84f08372f1cf1f30_MD5.png"></p>
<p>宁宁考虑的是这样一个问题：一个操作数序列，1,2,…,n（图示为 1 到 3 的情况），栈 A 的深度大于 n。</p>
<p>现在可以进行两种操作，</p>
<ol>
<li>将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）</li>
<li>将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）</li>
</ol>
<p>使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 <code>1 2 3</code> 生成序列 <code>2 3 1</code> 的过程。</p>
<p><img src="/img/assets/57d21a98fcc91801287a10e58bc79323_MD5.png"></p>
<p>（原始状态如上图所示）</p>
<p>你的程序将对给定的 n，计算并输出由操作数序列 1,2,…,n 经过操作可能得到的输出序列的总数。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>数据量 $（1≤n≤18）$</p>
<blockquote>
<p>想不出，开启嗯抄模式</p>
</blockquote>
<h3 id="抄-0"><a href="#抄-0" class="headerlink" title="抄#0 &lt;-TLE"></a>抄#0 &lt;-TLE</h3><p>询问了AI，采用了DFS思路<br>过了4个点，第五个TLE</p>
<h4 id="关键代码-12"><a href="#关键代码-12" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> in, <span class="type">int</span> out, <span class="type">int</span> stack_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 出栈数达到 n，说明是一种合法的出栈序列</span></span><br><span class="line">    <span class="keyword">if</span> (out == n) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以继续 push（前提是 in 还没用完）</span></span><br><span class="line">    <span class="keyword">if</span> (in &lt;= n) </span><br><span class="line">	    <span class="built_in">dfs</span>(in + <span class="number">1</span>, out, stack_size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可以 pop（前提是栈非空）</span></span><br><span class="line">    <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) </span><br><span class="line">	    <span class="built_in">dfs</span>(in, out + <span class="number">1</span>, stack_size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-7"><a href="#关键点-7" class="headerlink" title="关键点"></a>关键点</h4><p>采用DFS模拟出入栈，规模在指数级别</p>
<h3 id="抄-1"><a href="#抄-1" class="headerlink" title="抄#1"></a>抄#1</h3><h4 id="关键代码-13"><a href="#关键代码-13" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// memo[i][j] 表示 in=i, out=j 时的方案数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> memo[<span class="number">20</span>][<span class="number">20</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> in, <span class="type">int</span> out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out &gt; in || in &gt; n) </span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 非法状态：出栈多于入栈或超出n</span></span><br><span class="line">    <span class="keyword">if</span> (in == n &amp;&amp; out == n) </span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// 成功构造出合法出栈序列</span></span><br><span class="line">    <span class="keyword">if</span> (memo[in][out] != <span class="number">-1</span>) </span><br><span class="line">	    <span class="keyword">return</span> memo[in][out];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 尝试 push（in &lt; n）</span></span><br><span class="line">    <span class="keyword">if</span> (in &lt; n)</span><br><span class="line">        res += <span class="built_in">dfs</span>(in + <span class="number">1</span>, out);</span><br><span class="line">    <span class="comment">// 尝试 pop（stack_size &gt; 0 即 in &gt; out）</span></span><br><span class="line">    <span class="keyword">if</span> (in &gt; out)</span><br><span class="line">        res += <span class="built_in">dfs</span>(in, out + <span class="number">1</span>);</span><br><span class="line">    memo[in][out] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="built_in">sizeof</span>(memo));</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-8"><a href="#关键点-8" class="headerlink" title="关键点"></a>关键点</h4><p>DFS 中我们唯一决定当前状态的变量是：</p>
<ul>
<li><code>in</code>：已处理的输入个数（从序列中拿了几个数）</li>
<li><code>out</code>：已输出的个数（有几个数已出现在输出序列）</li>
<li><code>stack_size = in - out</code>：栈中元素数，也可以用 <code>in, out</code> 推导，不必单独记录<br><strong>状态唯一由 (in, out) 确定</strong>，所以我们用二维数组 <code>memo[in][out]</code> 记录状态。</li>
</ul>
<h3 id="抄-2"><a href="#抄-2" class="headerlink" title="抄#2"></a>抄#2</h3><h4 id="关键代码-14"><a href="#关键代码-14" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 20</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="comment">// base case：in = n, out = n，只有一种方式</span></span><br><span class="line">    dp[n][n] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n)</span><br><span class="line">	            <span class="comment">// push</span></span><br><span class="line">                dp[i][j] += dp[i + <span class="number">1</span>][j];  </span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n &amp;&amp; i &gt; j)</span><br><span class="line">	            <span class="comment">// pop，需保证 in &gt; out（栈不空）</span></span><br><span class="line">                dp[i][j] += dp[i][j + <span class="number">1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始状态：0 个入栈，0 个出栈</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键点-9"><a href="#关键点-9" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li><code>dp[i][j]</code> 表示从 in&#x3D;i，out&#x3D;j 状态出发，有多少种出栈序列</li>
<li>转移方程：<ul>
<li><code>dp[i][j] += dp[i+1][j]</code>（执行 push）</li>
<li><code>dp[i][j] += dp[i][j+1]</code>（执行 pop，需要 i &gt; j）</li>
</ul>
</li>
</ul>
<h3 id="抄-3"><a href="#抄-3" class="headerlink" title="抄#3"></a>抄#3</h3><h4 id="关键代码-15"><a href="#关键代码-15" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算栈出栈序列数的“一维空间压缩”DP</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dp_one</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[j] 在每一轮 i 中，初始存储 dp[i+1][j]</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[n] = <span class="number">1</span>;  <span class="comment">// base case：dp[n][n] = 1</span></span><br><span class="line">    <span class="comment">// 从 i = n → 0 依次“压缩”每一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// j 从右向左，保证 dp[j+1] 已经更新为 dp[i][j+1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="comment">// 只有当栈非空（i &gt; j）时，才能 pop</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; i)</span><br><span class="line">                dp[j] += dp[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];  <span class="comment">// 最终 dp[0] 即 dp[0][0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关键点-10"><a href="#关键点-10" class="headerlink" title="关键点"></a>关键点</h4><p>原始版本用的是：<br><code>long long dp[n+1][n+1];</code><br>观察状态转移：<br><code>dp[i][j] = dp[i+1][j] + dp[i][j+1] （条件成立时）</code><br>这是一个<strong>从右下角向左上角填表</strong>的问题：</p>
<ul>
<li><code>i</code> 是从大到小循环（即下一层依赖于上面一层的 <code>i+1</code>）</li>
<li><code>j</code> 也是从大到小循环（即依赖右侧的 <code>j+1</code>）</li>
</ul>
<h3 id="抄-4"><a href="#抄-4" class="headerlink" title="抄#4 &lt;-正解"></a>抄#4 &lt;-正解</h3><h4 id="1-定义与递推"><a href="#1-定义与递推" class="headerlink" title="1. 定义与递推"></a>1. 定义与递推</h4><p>记 $C_n$​ 为长度为 $n$ 的输入序列 $1,2,\dots,n$ 能生成的合法出栈序列总数。考察第一次使栈为空时刻：</p>
<ul>
<li>假设该时刻正好弹出了第 $2k+1$ 步（这里 k 次入栈、k 次出栈后，又入栈并立刻出栈一次），</li>
<li>则在此之前形成的子序列长度为 k 的合法出栈序列有 $C_k$ 种，</li>
<li>之后剩下的 $n-1-k$ 个元素也独立形成合法序列，有 $C_{n-1-k}$ 种。</li>
</ul>
<p>因此对所有可能的 $k&#x3D;0,1,\dots,n-1$ 求和，可得经典的卡特兰递推：<br>$$C_n ;&#x3D;; \sum_{k&#x3D;0}^{n-1} C_k , C_{n-1-k},\quad C_0&#x3D;1.$$</p>
<h4 id="2-生成函数法导出闭式"><a href="#2-生成函数法导出闭式" class="headerlink" title="2. 生成函数法导出闭式"></a>2. 生成函数法导出闭式</h4><p>定义生成函数<br>$$G(x) ;&#x3D;; \sum_{n&#x3D;0}^\infty C_n , x^n.$$<br>由递推可得<br>$$G(x) ;&#x3D;; 1 ;+; \sum_{n&#x3D;1}^\infty \Bigl(\sum_{k&#x3D;0}^{n-1}C_k,C_{n-1-k}\Bigr)x^n<br>       ;&#x3D;; 1 ;+; x,G(x)^2.$$<br>解一元二次方程：<br>$$x,G(x)^2 ;-; G(x) ;+; 1 ;&#x3D;; 0<br>\quad\Longrightarrow\quad<br>G(x) ;&#x3D;; \frac{1-\sqrt{1-4x}}{2x}.$$</p>
<h4 id="3-闭式表达"><a href="#3-闭式表达" class="headerlink" title="3. 闭式表达"></a>3. 闭式表达</h4><h2 id="利用二项式级数展开可得第-nnn-项系数：-C-n-frac-1-n-1-binom-2n-n-frac-2n-n-1-n-或者等价地：-C-n-binom-2n-n-binom-2n-n-1-4-小结最终，输入序列长度为-n-时，合法的出栈序列数恰好是第-n-个-卡特兰数：-C-n-frac-1-n-1-binom-2n-n-代码实现"><a href="#利用二项式级数展开可得第-nnn-项系数：-C-n-frac-1-n-1-binom-2n-n-frac-2n-n-1-n-或者等价地：-C-n-binom-2n-n-binom-2n-n-1-4-小结最终，输入序列长度为-n-时，合法的出栈序列数恰好是第-n-个-卡特兰数：-C-n-frac-1-n-1-binom-2n-n-代码实现" class="headerlink" title="利用二项式级数展开可得第 nnn 项系数：$$C_n ;&#x3D;; \frac{1}{n+1}\binom{2n}{n}       ;&#x3D;; \frac{(2n)!}{(n+1)!,n!}.$$或者等价地：$$C_n ;&#x3D;; \binom{2n}{n} ;-; \binom{2n}{n+1}.$$#### 4. 小结最终，输入序列长度为 n 时，合法的出栈序列数恰好是第 n 个 卡特兰数：$$C_n &#x3D; \frac{1}{n+1}\binom{2n}{n}.$$#### 代码实现"></a>利用二项式级数展开可得第 nnn 项系数：<br>$$C_n ;&#x3D;; \frac{1}{n+1}\binom{2n}{n}<br>       ;&#x3D;; \frac{(2n)!}{(n+1)!,n!}.<br>$$<br>或者等价地：<br>$$C_n ;&#x3D;; \binom{2n}{n} ;-; \binom{2n}{n+1}.<br>$$<br>#### 4. 小结<br>最终，输入序列长度为 n 时，合法的出栈序列数恰好是第 n 个 <strong>卡特兰数</strong>：<br>$$<br>C_n &#x3D; \frac{1}{n+1}\binom{2n}{n}.<br>$$<br>#### 代码实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算第 n 个卡特兰数 C_n = (1/(n+1)) * binom(2n, n)</span></span><br><span class="line"><span class="function">ll <span class="title">catalan</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ll c = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先计算 binom(2n, n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// c = c * (2n - i) / (i + 1)</span></span><br><span class="line">        c = c * (<span class="number">2LL</span> * n - i) / (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再除以 (n+1)</span></span><br><span class="line">    <span class="keyword">return</span> c / (n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">catalan</span>(n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="blog.l4place.icu">l4place</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/">http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">除特別声明外，本博客所有文章均遵守 WTFPL 许可。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8/">入门</a><a class="post-meta__tags" href="/tags/%E6%80%BB%E7%BB%93/">总结</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/27/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W06/" title="学习周报W06"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">学习周报W06</div></div><div class="info-2"><div class="info-item-1">要写重要的，写思路，写关键代码，写踩了什么坑，写能怎么优化！</div></div></div></a><a class="pagination-related" href="/2025/05/04/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W07/" title="学习周报W07"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">学习周报W07</div></div><div class="info-2"><div class="info-item-1">我深知我对于实践的缺乏，所以更需要奋勇向前。</div></div></div></a><a class="pagination-related" href="/2025/05/18/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W09/" title="学习周报W09"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-18</div><div class="info-item-2">学习周报W09</div></div><div class="info-2"><div class="info-item-1">又是开摆的一个星期，权当休息了吧。</div></div></div></a><a class="pagination-related" href="/2025/05/19/%E8%BD%BB%E9%87%8F%E7%BA%A7c++%E6%97%A5%E5%BF%97%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="轻量级c++日志库学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">轻量级c++日志库学习笔记</div></div><div class="info-2"><div class="info-item-1">基于 format 和 source_location 开发的轻量级c++日志库</div></div></div></a><a class="pagination-related" href="/2025/01/01/HELLOL4PLACE/" title="”Hello world！“"><img class="cover" src="/img/default_post_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-01</div><div class="info-item-2">”Hello world！“</div></div><div class="info-2"><div class="info-item-1">基于hexo框架的个人博客，以及其上二次开发的butterfly主题</div></div></div></a><a class="pagination-related" href="/2025/04/24/Codeforces%20Round%201017%20(Div.%204)/" title="Codeforces Round 1017 (Div. 4)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">Codeforces Round 1017 (Div. 4)</div></div><div class="info-2"><div class="info-item-1">Solutions in Codeforces Round 1017 (Div. 4)</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqusjs-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">L4plAce</div><div class="author-info-description">以空想为罗盘，以实践作航船</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/L4plAcEee"><i class="fab fa-github"></i><span>View in Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果图片碎了那就证明你需要挂梯子了 :- (</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Intro"><span class="toc-number">1.</span> <span class="toc-text">Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">每日算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E7%B3%BB%E5%88%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">算法通关系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85dp-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">背包dp-分组背包、完全背包</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85dp-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-1"><span class="toc-number">2.</span> <span class="toc-text">背包dp-分组背包、完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">2.2.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85-%E6%A8%A1%E7%89%88"><span class="toc-number">2.2.1.</span> <span class="toc-text">题目1 分组背包(模版)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3-0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">解#0 &lt;-AC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">主要问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%8F%96%E5%87%BAK%E4%B8%AA%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E5%80%BC%E5%92%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">题目2 从栈中取出K个硬币的最大面值和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">思路#0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mistake"><span class="toc-number">2.2.2.1.1.</span> <span class="toc-text">Mistake</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.1.2.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.2.1.3.</span> <span class="toc-text">优化 &lt;-空间压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%A8%A1%E7%89%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">题目3 完全背包(模版)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Code"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text">Code</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.4.</span> <span class="toc-text">题目4 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.5.</span> <span class="toc-text">题目5 通配符匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-%E8%B4%AD%E4%B9%B0%E8%B6%B3%E9%87%8F%E5%B9%B2%E8%8D%89%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9"><span class="toc-number">2.2.6.</span> <span class="toc-text">题目6 购买足量干草的最小花费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.6.1.1.</span> <span class="toc-text">自己的版本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%A3%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">正解版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95-1"><span class="toc-number">3.</span> <span class="toc-text">每日算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1036-NOIP-2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E9%80%89%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">Daily::算法 @P1036 [NOIP 2002 普及组] 选数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">思路#0 &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">关键点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">全局定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%90%9C"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">深搜</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-number">3.1.2.1.3.</span> <span class="toc-text">素数判断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">思考</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9ADFS-%E8%83%BD%E5%89%AA%E6%9E%9D%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">问题一：DFS 能剪枝吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">问题二：素数判断可以优化吗？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P3612-USACO17JAN-Secret-Cow-Code-S"><span class="toc-number">3.2.</span> <span class="toc-text">Daily::算法 @P3612 [USACO17JAN] Secret Cow Code S</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-2"><span class="toc-number">3.2.2.</span> <span class="toc-text">思路#0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">&lt;递归&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Code-1"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">Code</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%8B%E8%A1%8C"><span class="toc-number">3.2.2.1.2.</span> <span class="toc-text">压行</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1164-%E5%B0%8FA%E7%82%B9%E8%8F%9C"><span class="toc-number">3.3.</span> <span class="toc-text">Daily::算法 @P1164 小A点菜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-3"><span class="toc-number">3.3.2.</span> <span class="toc-text">思路#0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-0"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">提交#0 &lt;-WA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">提交#1 &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-2"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">关键点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1928-%E5%A4%96%E6%98%9F%E5%AF%86%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">Daily::算法 @P1928 外星密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-4"><span class="toc-number">3.4.2.</span> <span class="toc-text">思路#0 &lt;递归&gt; &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mistake-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">Mistake</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-3"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">可能的优化 &lt;显式栈&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%A0%88%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.4.2.4.0.1.</span> <span class="toc-text">显式栈思路：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.4.2.4.1.</span> <span class="toc-text">模拟过程：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P2437-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF"><span class="toc-number">3.5.</span> <span class="toc-text">Daily::算法 @P2437 蜜蜂路线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-5"><span class="toc-number">3.5.2.</span> <span class="toc-text">思路#0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-3"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.5.3.</span> <span class="toc-text">思路#1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-4"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mistake-2"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">Mistake</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.5.4.</span> <span class="toc-text">思路#2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-5"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1464-Function"><span class="toc-number">3.6.</span> <span class="toc-text">Daily::算法 @P1464 Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">3.6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-0-6"><span class="toc-number">3.6.2.</span> <span class="toc-text">思路#0 &lt;朴素DFS&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-6"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1-1"><span class="toc-number">3.6.3.</span> <span class="toc-text">思路#1 &lt;记忆化DFS&gt; &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mistake-3"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">Mistake</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF"><span class="toc-number">3.6.3.1.1.</span> <span class="toc-text">1. 函数调用错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E9%94%99%E8%AF%AF"><span class="toc-number">3.6.3.1.2.</span> <span class="toc-text">2. 初始化方式错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-7"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-4"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2-1"><span class="toc-number">3.6.4.</span> <span class="toc-text">思路#2 &lt;动态规划&gt; &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-8"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1028-NOIP-2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.7.</span> <span class="toc-text">Daily::算法 @P1028 [NOIP 2001 普及组] 数的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">3.7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">3.7.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-0-1"><span class="toc-number">3.7.3.</span> <span class="toc-text">提交#0 &lt;-TLE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-9"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">关键代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-1-1"><span class="toc-number">3.7.4.</span> <span class="toc-text">提交#1 &lt;-AC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-10"><span class="toc-number">3.7.4.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-5"><span class="toc-number">3.7.4.2.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-number">3.7.4.3.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E8%A7%A3%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.7.5.</span> <span class="toc-text">正解：动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-6"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-11"><span class="toc-number">3.7.5.2.</span> <span class="toc-text">关键代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daily-%E7%AE%97%E6%B3%95-P1044-NOIP-2003-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%A0%88"><span class="toc-number">3.8.</span> <span class="toc-text">Daily::算法 @P1044 [NOIP 2003 普及组] 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-number">3.8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">3.8.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%84-0"><span class="toc-number">3.8.3.</span> <span class="toc-text">抄#0 &lt;-TLE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-12"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-7"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%84-1"><span class="toc-number">3.8.4.</span> <span class="toc-text">抄#1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-13"><span class="toc-number">3.8.4.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-8"><span class="toc-number">3.8.4.2.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%84-2"><span class="toc-number">3.8.5.</span> <span class="toc-text">抄#2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-14"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-9"><span class="toc-number">3.8.5.2.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%84-3"><span class="toc-number">3.8.6.</span> <span class="toc-text">抄#3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-15"><span class="toc-number">3.8.6.1.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-10"><span class="toc-number">3.8.6.2.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%84-4"><span class="toc-number">3.8.7.</span> <span class="toc-text">抄#4 &lt;-正解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%80%92%E6%8E%A8"><span class="toc-number">3.8.7.1.</span> <span class="toc-text">1. 定义与递推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%B3%95%E5%AF%BC%E5%87%BA%E9%97%AD%E5%BC%8F"><span class="toc-number">3.8.7.2.</span> <span class="toc-text">2. 生成函数法导出闭式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AD%E5%BC%8F%E8%A1%A8%E8%BE%BE"><span class="toc-number">3.8.7.3.</span> <span class="toc-text">3. 闭式表达</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%E5%8F%AF%E5%BE%97%E7%AC%AC-nnn-%E9%A1%B9%E7%B3%BB%E6%95%B0%EF%BC%9A-C-n-frac-1-n-1-binom-2n-n-frac-2n-n-1-n-%E6%88%96%E8%80%85%E7%AD%89%E4%BB%B7%E5%9C%B0%EF%BC%9A-C-n-binom-2n-n-binom-2n-n-1-4-%E5%B0%8F%E7%BB%93%E6%9C%80%E7%BB%88%EF%BC%8C%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6%E4%B8%BA-n-%E6%97%B6%EF%BC%8C%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E6%95%B0%E6%81%B0%E5%A5%BD%E6%98%AF%E7%AC%AC-n-%E4%B8%AA-%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%EF%BC%9A-C-n-frac-1-n-1-binom-2n-n-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.9.</span> <span class="toc-text">利用二项式级数展开可得第 nnn 项系数：$$C_n ;&#x3D;; \frac{1}{n+1}\binom{2n}{n}       ;&#x3D;; \frac{(2n)!}{(n+1)!,n!}.$$或者等价地：$$C_n ;&#x3D;; \binom{2n}{n} ;-; \binom{2n}{n+1}.$$#### 4. 小结最终，输入序列长度为 n 时，合法的出栈序列数恰好是第 n 个 卡特兰数：$$C_n &#x3D; \frac{1}{n+1}\binom{2n}{n}.$$#### 代码实现12345678910111213141516171819202122#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;using ll &#x3D; long long;&#x2F;&#x2F; 计算第 n 个卡特兰数 C_n &#x3D; (1&#x2F;(n+1)) * binom(2n, n)ll catalan(int n) {    ll c &#x3D; 1;    &#x2F;&#x2F; 先计算 binom(2n, n)    for (int i &#x3D; 0; i &lt; n; ++i) {        &#x2F;&#x2F; c &#x3D; c * (2n - i) &#x2F; (i + 1)        c &#x3D; c * (2LL * n - i) &#x2F; (i + 1);    }    &#x2F;&#x2F; 再除以 (n+1)    return c &#x2F; (n + 1);}int main() {    int n;    cin &gt;&gt; n;    cout &lt;&lt; catalan(n) &lt;&lt; &quot;\n&quot;;    return 0;}</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/21/%E6%B5%85%E5%B0%9D%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96-%E5%90%8E%E7%AB%AF%E7%AF%87/" title="浅尝苍穹外卖-后端篇">浅尝苍穹外卖-后端篇</a><time datetime="2025-05-20T16:00:00.000Z" title="发表于 2025-05-21 00:00:00">2025-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/%E8%BD%BB%E9%87%8F%E7%BA%A7c++%E6%97%A5%E5%BF%97%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="轻量级c++日志库学习笔记">轻量级c++日志库学习笔记</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/18/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W09/" title="学习周报W09">学习周报W09</a><time datetime="2025-05-17T16:00:00.000Z" title="发表于 2025-05-18 00:00:00">2025-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/16/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/" title="学习方法论">学习方法论</a><time datetime="2025-05-15T16:00:00.000Z" title="发表于 2025-05-16 00:00:00">2025-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%9B%BE%E8%A1%A8/" title="如何绘制柱状图图表">如何绘制柱状图图表</a><time datetime="2025-05-14T16:00:00.000Z" title="发表于 2025-05-15 00:00:00">2025-05-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: #00bfff;"><div id="footer-wrap"><div class="copyright">&copy;2025 By L4plAce</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">数字，哲学与爱</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'== 'shuoshuo'
  const dqOption = null

  const destroyDisqusjs = () => {
    disqusjs.destroy()
    window.disqusjs = null
  }

  const themeChange = (el, path) => {
    destroyDisqusjs()
    initDisqusjs(el, path)
  }

  const initDisqusjs = (el = document, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyDisqusjs = () => {
        destroyDisqusjs()
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    disqusjs = new DisqusJS({
      shortname: 'l4place',
      title: '学习周报W08',
      apikey: 'x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8',
      ...dqOption,
      identifier: isShuoshuo ? path : (dqOption && dqOption.identifier) || '/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/',
      url: isShuoshuo ? location.origin + path : (dqOption && dqOption.url) || 'http://www.l4place.icu/2025/05/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W08/'
    })

    disqusjs.render(el.querySelector('#disqusjs-wrap'))

    btf.addGlobalFn('themeChange', () => themeChange(el, path), 'disqusjs')
  }

  const loadDisqusjs = async(el, path) => {
    if (window.disqusJsLoad) initDisqusjs(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/disqusjs/dist/browser/styles/disqusjs.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/disqusjs/dist/browser/disqusjs.es2015.umd.min.js')
      initDisqusjs(el, path)
      window.disqusJsLoad = true
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqusjs-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=l4place&api_key=x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()
      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if (isShuoshuo) {
    'Disqusjs' === 'Disqusjs'
      ? window.shuoshuoComment = { loadComment: loadDisqusjs }
      : window.loadOtherComment = loadDisqusjs
    return
  }

  if ('Disqusjs' === 'Disqusjs' || !false) {
    if (false) btf.loadComment(document.getElementById('disqusjs-wrap'), loadDisqusjs)
    else {
      loadDisqusjs()
      
    }
  } else {
    window.loadOtherComment = loadDisqusjs
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'disqus-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const getComment = ele => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=l4place&related=thread&limit=6&api_key=x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  run(keyName, getComment)
})</script><script defer src="https://fastly.jsdelivr.net/npm/live2d-widgets@0/autoload.js"></script><div class="aplayer no-destroy" data-id="2226764201" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>