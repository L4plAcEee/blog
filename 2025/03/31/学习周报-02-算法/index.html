<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>学习周报-02-算法 | L4plAce</title><meta name="author" content="L4plAce"><meta name="copyright" content="L4plAce"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="单调性结构维护着答案可能性，而我的可能性在何方？">
<meta property="og:type" content="article">
<meta property="og:title" content="学习周报-02-算法">
<meta property="og:url" content="http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="L4plAce">
<meta property="og:description" content="单调性结构维护着答案可能性，而我的可能性在何方？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.l4place.icu/img/avatar.jpg">
<meta property="article:published_time" content="2025-03-31T08:50:14.266Z">
<meta property="article:modified_time" content="2025-04-20T03:08:55.093Z">
<meta property="article:author" content="L4plAce">
<meta property="article:tag" content="入门">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.l4place.icu/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "学习周报-02-算法",
  "url": "http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/",
  "image": "http://www.l4place.icu/img/avatar.jpg",
  "datePublished": "2025-03-31T08:50:14.266Z",
  "dateModified": "2025-04-20T03:08:55.093Z",
  "author": [
    {
      "@type": "Person",
      "name": "l4place",
      "url": "https://www.l4place.icu"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-pm3JLit8G2"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?39def90aa4d3003d2e4e8308e7a8c9f3";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-18VE0KD5YB"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-18VE0KD5YB')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-18VE0KD5YB', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "q81b5s7cx2");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"43KWPP3572","apiKey":"ee8951db0bf1102393ba02871176539f","indexName":"new_blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习周报-02-算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #F5F5DC;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 日志</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/CHANGELOG.html"><i class="fa-fw fas fa-cloud"></i><span> 站点日志</span></a></li><li><a class="site-page child" href="/talking.html"><i class="fa-fw fas fa-comments"></i><span> 技术杂谈</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/about.html"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/flink.html"><i class="fa-fw fas fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.l4place.icu/img/index_top_img.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">L4plAce</span></a><a class="nav-page-title" href="/"><span class="site-name">学习周报-02-算法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 日志</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/CHANGELOG.html"><i class="fa-fw fas fa-cloud"></i><span> 站点日志</span></a></li><li><a class="site-page child" href="/talking.html"><i class="fa-fw fas fa-comments"></i><span> 技术杂谈</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/about.html"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/flink.html"><i class="fa-fw fas fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">学习周报-02-算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-31T08:50:14.266Z" title="发表于 2025-03-31 16:50:14">2025-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-20T03:08:55.093Z" title="更新于 2025-04-20 11:08:55">2025-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;自上次更新已经过了&quot;,&quot;messageNext&quot;:&quot;天，文章内容可能过期了哦！&quot;,&quot;postUpdate&quot;:&quot;2025-04-20 11:08:55&quot;}" hidden></div><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本周已学习：</p>
<ol>
<li>最大公约数、同余定理</li>
<li>对数器与暴力打表找规律</li>
<li>技巧：根据数据规模猜题解</li>
<li>前缀树</li>
<li>前缀和、差分</li>
<li>滑动窗口</li>
<li>双指针</li>
<li>二分答案</li>
<li>单调栈、单调队列</li>
<li>并查集</li>
<li>洪水填充</li>
</ol>
<p>其中涉及一些关于数论的结论，一些经验结论，以及两个新的数据结构（前缀树、并查集），和原有数据结构的新用法（单调栈、单调队列），同时学习了如何通过构建前缀信息以快速查询，还有通过差分数组传播影响，而洪水填充是一个dfs算法，真的很符合直觉，法如其名。</p>
<h2 id="最大公约数、同余定理"><a href="#最大公约数、同余定理" class="headerlink" title="最大公约数、同余定理"></a>最大公约数、同余定理</h2><h3 id="怎么求最大公约数和最小公倍数？-辗转相除法"><a href="#怎么求最大公约数和最小公倍数？-辗转相除法" class="headerlink" title="怎么求最大公约数和最小公倍数？- 辗转相除法"></a>怎么求最大公约数和最小公倍数？- 辗转相除法</h3><p>证明<strong>辗转相除法</strong>就是证明如下关系：<br><code>gcd(a, b) = gcd(b, a % b</code><br>假设a % b &#x3D; r，即需要证明的关系为：<br><code>gcd(a, b) = gcd(b, r)</code><br>证明过程：<br>因为a % b &#x3D; r，所以如下两个等式必然成立<br><strong>1) a &#x3D; b * q + r，q为0、1、2、3….中的一个整数</strong><br><strong>2) r &#x3D; a − b * q，q为0、1、2、3….中的一个整数</strong><br>假设u是a和b的公因子，则有: a &#x3D; s * u, b &#x3D; t * u<br>把a和b带入2)得到，<strong>r &#x3D; s * u - t * u * q &#x3D; (s - t * q) * u</strong><br>这说明 : u如果是a和b的公因子，那么u也是r的因子<br>假设v是b和r的公因子，则有: <strong>b &#x3D; x * v, r &#x3D; y * v</strong><br>把b和r带入1)得到，<strong>a &#x3D; x * v * q + y * v &#x3D; (x * q + y) * v</strong><br>这说明 : v如果是b和r的公因子，那么v也是a的公因子<br>综上，a和b的每一个公因子 也是 b和r的一个公因子，反之亦然<br>所以，a和b的全体公因子集合 &#x3D; b和r的全体公因子集合<br>即gcd(a, b) &#x3D; gcd(b, r)</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// cpp实现</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题分析："><a href="#例题分析：" class="headerlink" title="例题分析："></a>例题分析：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题目：魔数的数量</span><br><span class="line">https://leetcode.cn/problems/nth-magical-number/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h3><p>数学上的证明就不多说了，<br>总之就是用在大数据需要返回mod大质数结果的情况下，<br>我们可以通过对每个中间结果mod也能得出答案。</p>
<blockquote>
<p>除法需要逆元特殊处理。</p>
</blockquote>
<h2 id="对数器与暴力打表找规律"><a href="#对数器与暴力打表找规律" class="headerlink" title="对数器与暴力打表找规律"></a>对数器与暴力打表找规律</h2><p>使用场景：入参是简单类型，出参也是简单类型。<br>一般而言，用最暴力的实现进行求解，并在入参不大的情况下，<br>打表找规律，最后把规律变为代码。</p>
<h3 id="例题分析：-1"><a href="#例题分析：-1" class="headerlink" title="例题分析："></a>例题分析：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目: 要求只有一个长度&gt;=2的回文子串，求所有长度为n的red字符串中好串的数量</span><br></pre></td></tr></table></figure>
<p>分析：我们先分析基础情况，然后暴力打表（递归暴力搜索），打印出n在前100的答案，然后观察规律<br>最后发现了规律：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> <span class="title">num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;  <span class="comment">// &quot;rr&quot;, &quot;ee&quot;, &quot;dd&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">18</span>; <span class="comment">// 根据规律观察得到</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通用公式： 6 * (n + 1) % 1000000007</span></span><br><span class="line">	<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MOD = <span class="number">1000000007LL</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">6LL</span> * (n + <span class="number">1</span>)) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据数据量猜解法"><a href="#根据数据量猜解法" class="headerlink" title="根据数据量猜解法"></a>根据数据量猜解法</h2><p>C&#x2F;C++运行时间1s，<br>java&#x2F;python&#x2F;go等其他语言运行时间1s~2s，<br>对应的常数指令操作量是 10^7 ~ 10^8，<br>不管什么测试平台，不管什么cpu，都是这个数量级。<br>所以可以根据这个基本事实，<br>来猜测自己设计的算法最终有没有可能在规定时间内通过<br>也可以自己猜测一下大概的步数。<br>时间复杂度的估计很多时候并不是一个入参决定，<br>可能是多个入参共同决定。比如O(nm), O(n+m)等<br>所以最关键的就是记住常数指令操作量是 10^7 ~ 10^8，<br>然后方法是什么复杂度就可以估计能否通过了</p>
<table>
<thead>
<tr>
<th>问题规模</th>
<th>logn</th>
<th>n</th>
<th>n*logn</th>
<th>n*根号n</th>
<th>n^2</th>
<th>2^n</th>
<th>n!</th>
</tr>
</thead>
<tbody><tr>
<td>n &lt;&#x3D; 11</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>n &lt;&#x3D; 25</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>n &lt;&#x3D; 5000</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>n &lt;&#x3D; 10^5</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>n &lt;&#x3D; 10^6</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>n &lt;&#x3D; 10^7</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>n &gt;&#x3D; 10^8</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="例题分析：-2"><a href="#例题分析：-2" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-最优的技能释放顺序"><a href="#题目1-最优的技能释放顺序" class="headerlink" title="题目1 : 最优的技能释放顺序"></a>题目1 : 最优的技能释放顺序</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd">https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">现在有一个打怪类型的游戏，这个游戏是这样的，你有n个技能</span><br><span class="line">每一个技能会有一个伤害，</span><br><span class="line">同时若怪物小于等于一定的血量，则该技能可能造成双倍伤害</span><br><span class="line">每一个技能最多只能释放一次，已知怪物有m点血量</span><br><span class="line">现在想问你最少用几个技能能消灭掉他(血量小于等于0)</span><br><span class="line">技能的数量是n，怪物的血量是m</span><br><span class="line">i号技能的伤害是x[i]，i号技能触发双倍伤害的血量最小值是y[i]</span><br><span class="line">1 &lt;= n &lt;= 10</span><br><span class="line">1 &lt;= m、x[i]、y[i] &lt;= 10^6</span><br></pre></td></tr></table></figure>

<p>n的规模暗示了可接受的算法复杂度是n的阶乘，那么很容易就能想到是全排列。</p>
<h4 id="题目2：超级回文数的数目"><a href="#题目2：超级回文数的数目" class="headerlink" title="题目2：超级回文数的数目"></a>题目2：超级回文数的数目</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-palindromes/">https://leetcode.cn/problems/super-palindromes/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</span><br><span class="line">现在，给定两个正整数 L 和 R （以字符串形式表示），</span><br><span class="line">返回包含在范围 [L, R] 中的超级回文数的数目。</span><br><span class="line">1 &lt;= len(L) &lt;= 18</span><br><span class="line">1 &lt;= len(R) &lt;= 18</span><br><span class="line">L 和 R 是表示 [1, 10^18) 范围的整数的字符串</span><br></pre></td></tr></table></figure>

<p>10^18，这很大啊，这就让我们不得不去想一些特殊解法<br>如果把题目问题看为主问题，那么求我们是不是可以先求超级回文数的开方是否回文从而逆向验证主问题呢？（这好像叫种子问题？）<br>如果用这个思路，规模直接下降到了sqrt（10^18）变成了10^9。<br>好像还是有点大了，我们能不能再次找到种子问题二，从而再度下降问题规模呢？<br>有点兄弟有的，我们只需要构造种子问题一的前半数据并验证即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于前半部分数据：123</span><br><span class="line">可以构造出回文数：12321 与 123321</span><br></pre></td></tr></table></figure>
<p>此时规模又缩减sqrt（10^9) 变成了 10^5。<br>整理思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sd2() -&gt; sd1() -&gt; main()</span><br><span class="line">一个满足main的问题，首先必须要满足sd1，而问题sd1必须要满足sd2。</span><br><span class="line">总之，我们只需要枚举小规模的数字，然后通过链条逐渐放大即可。</span><br></pre></td></tr></table></figure>

<p>通过打表可以优化为直接返回列表中的记录~：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 预先计算的超级回文数的平方值列表</span></span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; record = &#123;</span><br><span class="line">        <span class="number">1L</span>, <span class="number">4L</span>, <span class="number">9L</span>, <span class="number">121L</span>, <span class="number">484L</span>, <span class="number">10201L</span>, <span class="number">12321L</span>, <span class="number">14641L</span>, <span class="number">40804L</span>, <span class="number">44944L</span>,</span><br><span class="line">        <span class="number">1002001L</span>, <span class="number">1234321L</span>, <span class="number">4008004L</span>, <span class="number">100020001L</span>, <span class="number">102030201L</span>, <span class="number">104060401L</span>,</span><br><span class="line">        <span class="number">121242121L</span>, <span class="number">123454321L</span>, <span class="number">125686521L</span>, <span class="number">400080004L</span>, <span class="number">404090404L</span>,</span><br><span class="line">        <span class="number">10000200001L</span>, <span class="number">10221412201L</span>, <span class="number">12102420121L</span>, <span class="number">12345654321L</span>,</span><br><span class="line">        <span class="number">40000800004L</span>, <span class="number">1000002000001L</span>, <span class="number">1002003002001L</span>, <span class="number">1004006004001L</span>,</span><br><span class="line">        <span class="number">1020304030201L</span>, <span class="number">1022325232201L</span>, <span class="number">1024348434201L</span>, <span class="number">1210024200121L</span>,</span><br><span class="line">        <span class="number">1212225222121L</span>, <span class="number">1214428244121L</span>, <span class="number">1232346432321L</span>, <span class="number">1234567654321L</span>,</span><br><span class="line">        <span class="number">4000008000004L</span>, <span class="number">4004009004004L</span>, <span class="number">100000020000001L</span>, <span class="number">100220141022001L</span>,</span><br><span class="line">        <span class="number">102012040210201L</span>, <span class="number">102234363432201L</span>, <span class="number">121000242000121L</span>,</span><br><span class="line">        <span class="number">121242363242121L</span>, <span class="number">123212464212321L</span>, <span class="number">123456787654321L</span>,</span><br><span class="line">        <span class="number">400000080000004L</span>, <span class="number">10000000200000001L</span>, <span class="number">10002000300020001L</span>,</span><br><span class="line">        <span class="number">10004000600040001L</span>, <span class="number">10020210401202001L</span>, <span class="number">10022212521222001L</span>,</span><br><span class="line">        <span class="number">10024214841242001L</span>, <span class="number">10201020402010201L</span>, <span class="number">10203040504030201L</span>,</span><br><span class="line">        <span class="number">10205060806050201L</span>, <span class="number">10221432623412201L</span>, <span class="number">10223454745432201L</span>,</span><br><span class="line">        <span class="number">12100002420000121L</span>, <span class="number">12102202520220121L</span>, <span class="number">12104402820440121L</span>,</span><br><span class="line">        <span class="number">12122232623222121L</span>, <span class="number">12124434743442121L</span>, <span class="number">12321024642012321L</span>,</span><br><span class="line">        <span class="number">12323244744232321L</span>, <span class="number">12343456865434321L</span>, <span class="number">12345678987654321L</span>,</span><br><span class="line">        <span class="number">40000000800000004L</span>, <span class="number">40004000900040004L</span>, <span class="number">1000000002000000001L</span>,</span><br><span class="line">        <span class="number">1000220014100220001L</span>, <span class="number">1002003004003002001L</span>, <span class="number">1002223236323222001L</span>,</span><br><span class="line">        <span class="number">1020100204020010201L</span>, <span class="number">1020322416142230201L</span>, <span class="number">1022123226223212201L</span>,</span><br><span class="line">        <span class="number">1022345658565432201L</span>, <span class="number">1210000024200000121L</span>, <span class="number">1210242036302420121L</span>,</span><br><span class="line">        <span class="number">1212203226223022121L</span>, <span class="number">1212445458545442121L</span>, <span class="number">1232100246420012321L</span>,</span><br><span class="line">        <span class="number">1232344458544432321L</span>, <span class="number">1234323468643234321L</span>, <span class="number">4000000008000000004L</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>前缀树又叫字典树，英文名trie，<br>这个名字来源于英文单词“retrieval”（检索），因为前缀树是一种专门用于高效检索和存储字符串的数据结构。它的命名是为了突出其在信息检索中的应用。<br>每个样本都从头节点开始根据前缀字符或者前缀数字建出来的一棵大树，就是前缀树<br>前缀树的使用场景：需要根据前缀信息来查询的场景<br>前缀树的优点：根据前缀信息选择树上的分支，可以节省大量的时间<br>前缀树的缺点：比较浪费空间，和总字符数量有关，字符的种类有关<br>前缀树的定制：pass、end等信息<br>对于前缀树的建立有两种方法，<br>一种是通过动态结构建立前缀树，一种是通过静态数组建立。<br>在工程上我们一般通过动态结构来确保工程上的安全性，<br>而比赛中为了追求极致效率，一般我们就直接用静态数组构建前缀树。</p>
<blockquote>
<p>总结就是：没有路就新建节点；已经有路了，就复用节点。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    root((root))</span><br><span class="line">    root --&gt; a1(a)</span><br><span class="line">    a1 --&gt; p1(p)</span><br><span class="line">    p1 --&gt; p2(p)</span><br><span class="line">    p2 --&gt; l(l)</span><br><span class="line">    l --&gt; e(e)</span><br><span class="line">    p2 --&gt; app[&quot;app&quot;]</span><br><span class="line">    e --&gt; apple[&quot;apple&quot;]</span><br><span class="line">    root --&gt; b1(b)</span><br><span class="line">    b1 --&gt; a2(a)</span><br><span class="line">    a2 --&gt; n(n)</span><br><span class="line">    n --&gt; a3(a)</span><br><span class="line">    a3 --&gt; banana[&quot;banana&quot;]</span><br><span class="line">    n --&gt; d(d)</span><br><span class="line">    d --&gt; band[&quot;band&quot;]</span><br><span class="line">    style app fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style apple fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style banana fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style band fill:#f9f,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure>


<h3 id="例题分析：-3"><a href="#例题分析：-3" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-接头密匙"><a href="#题目1-接头密匙" class="headerlink" title="题目1 接头密匙"></a>题目1 接头密匙</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932">https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份</span><br><span class="line">密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：</span><br><span class="line">密匙 b 的长度不超过密匙 a 的长度。</span><br><span class="line">对于任意 0 &lt;= i &lt; length(b)，有b[i+1] - b[i] == a[i+1] - a[i]</span><br><span class="line">现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组</span><br><span class="line">请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙</span><br><span class="line">数组 a 和数组 b 中的元素个数均不超过 10^5</span><br><span class="line">1 &lt;= m, n &lt;= 1000</span><br><span class="line"></span><br><span class="line">用前缀树方法：</span><br><span class="line">时间复杂度，O(a数组的数字个数 * 10) + O(b数组的数字个数 * 10)</span><br><span class="line">空间复杂度，O(a数组的数字个数 * 10)，这是树上的节点数量</span><br></pre></td></tr></table></figure>
<p>将数字序列的差分数组转换为字符串表示<br>例如原差分<code>[1, -3, 9] -&gt; &quot;1#-3#9#&quot;</code><br>这样就可以防止大量Path消耗大量内存</p>
<h4 id="题目2-数组中两个数的最大异或值"><a href="#题目2-数组中两个数的最大异或值" class="headerlink" title="题目2 数组中两个数的最大异或值"></a>题目2 数组中两个数的最大异或值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0&lt;=i&lt;=j&lt;=n</span><br><span class="line">1 &lt;= nums.length &lt;= 2 * 10^5</span><br><span class="line">0 &lt;= nums[i] &lt;= 2^31 - 1</span><br><span class="line">前缀树做法 &amp; 哈希表做法</span><br><span class="line">时间复杂度O(n * logV)，空间复杂度O(n * logV)，V是数值范围</span><br></pre></td></tr></table></figure>
<p>把x数字看作一个二进制串<br>得到了一个类似”00100…..001110”的东西。<br>所谓 x xor y 得到最大，<br>就是从高位向下检索，尽可能走的满足 x 与 y的当前相等位状态相反的路径。<br>这就是天然的前缀思路，故前缀树解法显现。</p>
<h4 id="题目3-在二维字符数组中搜索可能的单词"><a href="#题目3-在二维字符数组中搜索可能的单词" class="headerlink" title="题目3 在二维字符数组中搜索可能的单词"></a>题目3 在二维字符数组中搜索可能的单词</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">https://leetcode.cn/problems/word-search-ii/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words</span><br><span class="line">返回所有二维网格上的单词。单词必须按照字母顺序，通过 相邻的单元格 内的字母构成</span><br><span class="line">其中“相邻”单元格是那些水平相邻或垂直相邻的单元格</span><br><span class="line">同一个单元格内的字母在一个单词中不允许被重复使用</span><br><span class="line">1 &lt;= m, n &lt;= 12</span><br><span class="line">1 &lt;= words.length &lt;= 3 * 10^4</span><br><span class="line">1 &lt;= words[i].length &lt;= 10</span><br><span class="line"></span><br><span class="line">时间复杂度，O(m * n * 4^10)</span><br><span class="line">不管用不用前缀树都是这个复杂度，只不过前缀树可以大量剪枝，优化常数时间</span><br><span class="line">空间复杂度，O(words中所有字符串的全部字符数量)</span><br></pre></td></tr></table></figure>
<p>一眼trie + dfs, 图遍历嘛，用dfs很好理解，但trie在哪？<br>trie在于把给定要搜索的单词作为路径放入前缀树中，<br>相当于dfs在搜索的时候持有一个地图，如果地图上显示没路可走了，那就直接cut。<br>trie妙用：<br>    1. end属性存储字符串便于收获结果<br>    2. 在收获答案往回退时顺便减去pass属性，如果下次再来，访问到pass属性&#x3D;&#x3D; 0就cut</p>
<h2 id="前缀和、差分"><a href="#前缀和、差分" class="headerlink" title="前缀和、差分"></a>前缀和、差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和是通过滚动求和记录当前位置累加和所构建的数组，<br>是一种通过保留前缀信息以减少查询时间的技巧。<br>所谓前缀和实际上就是区间和。<br>记录的是 0<del>1、0</del>2、0<del>3直到0</del>n的区间的累加和。<br>而由两个大小区间相减我们便可以得到所需区间的值。<br>例如我们如果需要4<del>5区间的值，完全可以拿0</del>5 - 0<del>3区间的值，<br>这样便剩下了4</del>5区间的值。</p>
<h3 id="例题分析：构建前缀信息的技巧-解决子数组相关问题"><a href="#例题分析：构建前缀信息的技巧-解决子数组相关问题" class="headerlink" title="例题分析：构建前缀信息的技巧-解决子数组相关问题"></a>例题分析：构建前缀信息的技巧-解决子数组相关问题</h3><p>解决如下问题，时间复杂度O(n)</p>
<ul>
<li><p>题目1 : 构建 前缀和数组。快速解决子数组范围求和的问题<br>  测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p>
</li>
<li><p>题目2 : 构建 前缀和 最早出现的位置。返回 无序数组中 累加和为给定值的 最长子数组长度<br>  测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5">https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5</a></p>
</li>
<li><p>题目3 : 构建 前缀和 出现的次数。返回 无序数组中 累加和为给定值的 子数组数量<br>  测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
</li>
<li><p>题目4 : 构建 前缀和 最早出现的位置。返回 无序数组中 正数和负数个数相等的 最长子数组长度<br>  测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb">https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb</a></p>
</li>
<li><p>题目5 : 构建 前缀和 最早出现的位置。表现良好的最长时间段问题<br>  测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-well-performing-interval/">https://leetcode.cn/problems/longest-well-performing-interval/</a></p>
</li>
<li><p>题目6 : 构建 前缀和余数 最晚出现的位置。移除的最短子数组长度，使得剩余元素的累加和能被p整除<br>  测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-sum-divisible-by-p/">https://leetcode.cn/problems/make-sum-divisible-by-p/</a></p>
</li>
<li><p>题目7 : 构建 前缀奇偶状态 最早出现的位置。每个元音包含偶数次的 最长子串长度<br>  测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/">https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/</a></p>
</li>
</ul>
<h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>差分实际上是在前缀和技巧的基础上传播影响的技巧<br>例如你想要在数组上对 n~m区间加上一个数 x，其他区间不变。<br>实际上你只需要在差分数组上在n位置加上x，而在m + 1位置减去 x，然后使用前缀和构建数组后你会发现，n位置上的影响会自动传播，覆盖n ~ 结尾的区间，所以也就是为什么我们需要在m + 1 的位置减去x，这样可以覆盖掉来自n位置对m ~ 结尾的影响。<br>对于二维也是如此。</p>
<p>一维差分：太简单了，没有理解难度。不支持边操作、边查询。</p>
<p>等差数列差分问题描述：<br>一开始1<del>n范围上的数字都是0。接下来一共有m个操作。<br>每次操作：l</del>r范围上依次加上首项s、末项e、公差d的数列<br>最终1~n范围上的每个数字都要正确得到</p>
<p>等差数列差分的过程：<br>每个操作调用set方法<br>所有操作完成后在arr上生成两遍前缀和，即调用build方法<br>arr里就是最终1~n范围上的每个数字</p>
<h3 id="例题分析：-4"><a href="#例题分析：-4" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><blockquote>
<p>航班预订统计 测试链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这里有 n 个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line">有一份航班预订表 bookings ，</span><br><span class="line">表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]</span><br><span class="line">意味着在从 firsti 到 lasti </span><br><span class="line">包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</span><br><span class="line">请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</span><br></pre></td></tr></table></figure>
<p>标准差分做法，建立差分数组，然后通过前缀和技巧收集答案。</p>
<h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><blockquote>
<p>等差数列差分模版 测试链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4231">https://www.luogu.com.cn/problem/P4231</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)</span><br><span class="line">表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列</span><br><span class="line">M个操作做完之后，统计1~n范围上所有数字的最大值和异或和</span><br><span class="line">1 &lt;= n &lt;= 10^7</span><br><span class="line">1 &lt;= m &lt;= 3 * 10^5</span><br><span class="line">1 &lt;= l &lt;= r &lt;= n</span><br></pre></td></tr></table></figure>
<h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><blockquote>
<p>等差数列差分经典题目 测试链接 : <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5026">https://www.luogu.com.cn/problem/P5026</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一群人落水后求每个位置的水位高度</span><br><span class="line">问题描述比较复杂，见测试链接</span><br><span class="line">注意：这道题OFFSET的设计，可以避免大量的边界讨论</span><br></pre></td></tr></table></figure>
<p>如果把一般差分对后续区间的影响看做一条直线，那么等差数列差分便是一条斜线线。</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>为什么我们要构建二维前缀和？<br>目的是预处理出一个结构，以后每次查询二维数组任何范围上的累加和都是O(1)的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 根据原始状况，生成二维前缀和数组sum，</span><br><span class="line">   sum[i][j]: 代表左上角(0,0)到右下角(i,j)这个范围的累加和</span><br><span class="line">   sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];</span><br><span class="line">2 查询左上角(a,b)到右下角(c,d)这个范围的累加和</span><br><span class="line">   sum[c][d] - sum[c][b-1] - sum[a-1][d] + sum[a-1][b-1];</span><br><span class="line">3 实际过程中往往补第0行、第0列来减少很多条件判断。</span><br><span class="line">  当然也可以不补。根据个人习惯决定。</span><br></pre></td></tr></table></figure>

<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>在二维数组中，如果经历如下的过程<br>1 批量的做如下的操作，每个操作都有独立的a、b、c、d、v<br>void add(a, b, c, d, v) : 左上角(a,b)到右下角(c,d)范围上，每个数字+v，怎么快速处理？<br>2 操作做完后，如何正确得到二维数组中每个位置的值？</p>
<p>这就是二维差分的主要工作，add时候快速处理，最后build得到每个位置的值，修改操作必须集中在一起，不能边修改边查询。<br>1）add方法实现，比较巧妙！<br>2）build方法实现，和处理前缀和类似<br>3）真实数据用一圈0包裹起来，可以减少很多边界讨论</p>
<h3 id="例题分析：-5"><a href="#例题分析：-5" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-1"><a href="#题目1-1" class="headerlink" title="题目1"></a>题目1</h4><p>二维前缀和模版<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a></p>
<h4 id="题目2-1"><a href="#题目2-1" class="headerlink" title="题目2"></a>题目2</h4><p>边框为1的最大正方形<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-1-bordered-square/">https://leetcode.cn/problems/largest-1-bordered-square/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个由若干 0 和 1 组成的二维网格 grid</span><br><span class="line">请你找出边界全部由 1 组成的最大 正方形 子网格</span><br><span class="line">并返回该子网格中的元素数量。如果不存在，则返回 0。</span><br></pre></td></tr></table></figure>
<p>就是整个正方形扣掉中间那一块计算出来的值是不是等于边界全由一组成的值就行。</p>
<h4 id="题目3-1"><a href="#题目3-1" class="headerlink" title="题目3"></a>题目3</h4><p>二维差分模版<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc">https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3397">https://www.luogu.com.cn/problem/P3397</a></p>
<h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p>用邮票贴满网格图<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stamping-the-grid/">https://leetcode.cn/problems/stamping-the-grid/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你一个 m * n 的二进制矩阵 grid</span><br><span class="line">每个格子要么为 0 （空）要么为 1 （被占据）</span><br><span class="line">给你邮票的尺寸为 stampHeight * stampWidth</span><br><span class="line">我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</span><br><span class="line">覆盖所有空格子，不覆盖任何被占据的格子</span><br><span class="line">可以放入任意数目的邮票，邮票可以相互有重叠部分</span><br><span class="line">邮票不允许旋转，邮票必须完全在矩阵内</span><br><span class="line">如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false</span><br></pre></td></tr></table></figure>
<p>遍历所有可能放置邮票的左上角位置 (i, j)<br>计算 (i, j) 到 (i + stampHeight - 1, j + stampWidth - 1) 这个区域的和<br>计算 cnt 的前缀和，用于快速查询某个区域是否有邮票<br>检查所有的 0 是否都被覆盖</p>
<h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><blockquote>
<p>重要！包含离散化技巧！</p>
</blockquote>
<p>最强祝福力场<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xepqZ5/">https://leetcode.cn/problems/xepqZ5/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小扣在探索丛林的过程中，无意间发现了传说中&quot;落寞的黄金之都&quot;</span><br><span class="line">而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场</span><br><span class="line">经过不断的勘测记录，小扣将所有力场的分布都记录了下来</span><br><span class="line">forceField[i] = [x,y,side] </span><br><span class="line">表示第 i 片力场将覆盖以坐标 (x,y) 为中心，边长为 side 的正方形区域。</span><br><span class="line">若任意一点的 力场强度 等于覆盖该点的力场数量</span><br><span class="line">请求出在这片地带中 力场强度 最强处的 力场强度</span><br><span class="line">注意：力场范围的边缘同样被力场覆盖。</span><br></pre></td></tr></table></figure>
<p>由于本题可能要我们处理类似1.5、0.5之类的值，但是我们期望继续使用整型处理，<br>这里使用离散化技巧，我们可以让所有的坐标倍增一个倍数，类似于整体拉长整个坐标，于是我们就可以发现，原来的不好处理的数字现在落到了好处理的坐标上，而且所有的相对位置都没有发生改变。<br>有种分辨率变大的感觉~</p>
<p>本题就是通过构建二维差分数组，计算叠加每次立场的强度，然后最后找到最大强度即可。<br>但是坑点在于数字很大，n会来到10^9的规模，怎么办呢？<br>这时候就要处理数据，<br>我们可以记录每一个点x坐标所在位置<br>例如<code>1、73、103、1009、114514</code><br>然后将其映射到：<code>1、2、3、4、5</code>,同理处理y坐标。<br>这样我们就发现我们可以省下很多没用到的坐标。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口：维持左、右边界都不回退的一段范围，来求解很多子数组（串）的相关问题<br>滑动窗口的关键：找到 <strong>范围</strong> 和 <strong>答案指标</strong> 之间的 单调性关系（类似贪心）<br>滑动过程：滑动窗口可以用 简单变量 或者 结构 来 维护信息<br>求解大流程：求子数组在 每个位置 开头 或 结尾 情况下的答案（开头还是结尾在于个人习惯）</p>
<h3 id="例题分析：-6"><a href="#例题分析：-6" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-2"><a href="#题目1-2" class="headerlink" title="题目1"></a>题目1</h4><p>累加和大于等于target的最短子数组长度<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 target</span><br><span class="line">找到累加和 &gt;= target 的长度最小的子数组并返回其长度</span><br><span class="line">如果不存在符合条件的子数组返回0</span><br></pre></td></tr></table></figure>
<p>维持一个累加和大于 target的滑窗，然后沿途记录滑窗size的最大值即可。</p>
<h4 id="题目2-2"><a href="#题目2-2" class="headerlink" title="题目2"></a>题目2</h4><p>无重复字符的最长子串<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span><br></pre></td></tr></table></figure>
<p>维持一个不重复字符的滑窗，沿途收集最大size。</p>
<h4 id="题目3-2"><a href="#题目3-2" class="headerlink" title="题目3"></a>题目3</h4><p>最小覆盖子串<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串</span><br><span class="line">如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span><br></pre></td></tr></table></figure>
<p>维持一个含有t中所有字符的滑窗（可以用used数组实现），然后记录最小size即可</p>
<h4 id="题目4-1"><a href="#题目4-1" class="headerlink" title="题目4"></a>题目4</h4><p>加油站<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span><br><span class="line">你有一辆油箱容量无限的的汽车，</span><br><span class="line">从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升</span><br><span class="line">你从其中的一个加油站出发，开始时油箱为空。</span><br><span class="line">给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周</span><br><span class="line">则返回出发时加油站的编号，否则返回 -1</span><br><span class="line">如果存在解，则 保证 它是 唯一 的。</span><br></pre></td></tr></table></figure>
<p>环形数组滑窗：</p>
<ul>
<li><strong>如果总油量不小于总消耗量，则一定有解。</strong></li>
<li><strong>当 <code>currentSum &lt; 0</code> 时，说明此前的起始点不可行，更新 <code>startIndex</code>。</strong></li>
<li><strong>最终返回 <code>startIndex</code> 作为起点，或者返回 <code>-1</code> 表示无法绕一圈。</strong></li>
</ul>
<h4 id="题目5-1"><a href="#题目5-1" class="headerlink" title="题目5"></a>题目5</h4><p>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">https://leetcode.cn/problems/replace-the-substring-for-balanced-string/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">替换子串得到平衡字符串</span><br><span class="line">有一个只含有&#x27;Q&#x27;,&#x27;W&#x27;,&#x27;E&#x27;,&#x27;R&#x27;四种字符，且长度为n的字符串，n一定为4的整数倍</span><br><span class="line">假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」</span><br><span class="line">给你一个这样的字符串s，请通过「替换一个子串」的方式，</span><br><span class="line">使原字符串s变成一个「平衡字符串」</span><br><span class="line">子串可以替换成由&#x27;Q&#x27;,&#x27;W&#x27;,&#x27;E&#x27;,&#x27;R&#x27;四种字符组成的任何样子</span><br><span class="line">请返回待替换子串的最小可能长度</span><br><span class="line">如果原字符串自身就是一个平衡字符串，则返回0</span><br></pre></td></tr></table></figure>
<p>要点：不够四分之一要补足，够了四分之一就不用关了。</p>
<h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p>K个不同整数的子数组<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarrays-with-k-different-integers/">https://leetcode.cn/problems/subarrays-with-k-different-integers/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</span><br><span class="line">如果 nums 的某个子数组中不同整数的个数恰好为 k</span><br><span class="line">则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</span><br><span class="line">例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。</span><br><span class="line">子数组 是数组的 连续 部分。</span><br></pre></td></tr></table></figure>
<p>维护cnt数组辅助记录出现次数信息，在入窗时检测次数合法性。</p>
<h4 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h4><p>至少有K个重复字符的最长子串<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串</span><br><span class="line">要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度</span><br><span class="line">如果不存在这样的子字符串，则返回 0。</span><br></pre></td></tr></table></figure>
<p>每次要求子串必须含有 require 种字符，每种字符都必须&gt;&#x3D;k次，这样的最长子串是多长<br>collect : 窗口中一共收集到的种类数<br>satisfy : 窗口中达标的种类数(次数&gt;&#x3D;k)</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>设置两个指针的技巧，其实这种说法很宽泛，似乎 没什么可总结的<br>1）有时候所谓的双指针技巧，就单纯是代码过程用双指针的形式表达出来而已。<br>   没有单调性（贪心）方面的考虑<br>2）有时候的双指针技巧包含单调性（贪心）方面的考虑，牵扯到可能性的取舍。<br>   对分析能力的要求会变高。其实是先有的思考和优化，然后代码变成了 双指针的形式。<br>3）所以，双指针这个“皮”不重要，分析题目单调性（贪心）方面的特征，这个能力才重要。</p>
<p>常见的双指针类型：<br>1）同向双指针<br>2）快慢双指针<br>3）从两头往中间的双指针<br>4）其他</p>
<h3 id="例题分析：-7"><a href="#例题分析：-7" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-3"><a href="#题目1-3" class="headerlink" title="题目1"></a>题目1</h4><p>按奇偶排序数组II<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-array-by-parity-ii/">https://leetcode.cn/problems/sort-array-by-parity-ii/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组 nums。nums 中一半整数是奇数 ，一半整数是偶数</span><br><span class="line">对数组进行排序，以便当 nums[i] 为奇数时，i也是奇数</span><br><span class="line">当 nums[i] 为偶数时， i 也是 偶数</span><br><span class="line">你可以返回 任何满足上述条件的数组作为答案</span><br><span class="line">不同的说法，同一个题：</span><br><span class="line">给定一个数组arr，请把arr调整成 奇数都在奇数位置 或者 偶数都在偶数位置</span><br></pre></td></tr></table></figure>
<p>第一眼我们可能会想到，可以开一个辅助数组，然后遍历原数组，<br>将对应的数放在对应位置上。<br>双指针则是优化了空间，我们其实不需要开这个数组，<br>我们可以一个指针固定看数组最后一位的偶数位，<br>然后以另一指针指向奇数位，如果位置上已经奇数则跳下一个奇数位，如果位置上是偶数则发货至偶数位，偶数位指针往前跳。</p>
<h4 id="题目2-3"><a href="#题目2-3" class="headerlink" title="题目2"></a>题目2</h4><p>寻找重复数<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，</span><br><span class="line">其数字都在 [1, n] 范围内（包括 1 和 n）</span><br><span class="line">可知至少存在一个重复的整数。</span><br><span class="line">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span><br><span class="line">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span><br></pre></td></tr></table></figure>
<p>实际上本题可以转换为图的连通分量求环<br>直接使用经典双指针算法：Floyd 判环法，寻找相遇点。</p>
<h4 id="题目3-3"><a href="#题目3-3" class="headerlink" title="题目3"></a>题目3</h4><p>接雨水<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，</span><br><span class="line">计算按此排列的柱子，下雨之后能接多少雨水</span><br></pre></td></tr></table></figure>
<p>经典接雨水。<br>接雨水的本质就是对于某一个柱子i，会有一个水线，<br>而水线来自左右区间的极值较小值，<br>所蓄的水量则为高度减去水线。<br>我们可以构建两个数组用于存储左-&gt;右区间的极值和左&lt;-右区间的极值，用于快速查询。<br>而双指针妙就妙在优化掉了这两个辅助数组。<br>双指针一个指向1位置，另一个指向末尾减去2的位置，然后分别设定极值为0位置和末尾位置的值。对于左右指针，左指针的左极值是真实的，而右区间极值是待定的，反之则反。<br>可以看出，如果左指针的左极值要成为计算水线的值，那么左指针就可以马上收获答案，反之则反。<br>这样就不需要额外维护两个数组了。</p>
<h4 id="题目4-2"><a href="#题目4-2" class="headerlink" title="题目4"></a>题目4</h4><p>救生艇<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/boats-to-save-people/">https://leetcode.cn/problems/boats-to-save-people/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 people</span><br><span class="line">people[i]表示第 i 个人的体重 ，船的数量不限</span><br><span class="line">每艘船可以承载的最大重量为 limit</span><br><span class="line">每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit</span><br><span class="line">返回 承载所有人所需的最小船数</span><br><span class="line">扩展：</span><br><span class="line">再增加一个要求，如果两人一船那么体重之和必须是偶数，又该怎么做？（大厂真考过）</span><br></pre></td></tr></table></figure>
<p>注意到排序不会影响答案，果断排序。<br>排完序之后，直接贪心算法，尽量大匹配尽量小。<br>如果两者匹配之后能坐下一艘船就坐，坐不下就让大的坐。<br>转换为代码就是两枚指针，l指向开头，r指向末尾，<br>左右指针不断的用以上逻辑往中间移动即可。<br>最后结束循环再判断一下l &#x3D;&#x3D; r ? 如果相等就意味着还有一个没被分配，<br>为其单独分配一艘船，ans++即可。</p>
<h4 id="题目5-2"><a href="#题目5-2" class="headerlink" title="题目5"></a>题目5</h4><p>盛最多水的容器<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个长度为 n 的整数数组 height</span><br><span class="line">有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])</span><br><span class="line">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水</span><br><span class="line">返回容器可以储存的最大水量</span><br><span class="line">说明：你不能倾斜容器</span><br></pre></td></tr></table></figure>
<p>思路是这样的，左右指针往开头结尾一放，往中间走，谁小移动谁，移动时记录极值。<br>至于为什么，实际上是大的被待定了，它期望小的往下走能遇到更大的。</p>
<h4 id="题目6-1"><a href="#题目6-1" class="headerlink" title="题目6"></a>题目6</h4><p>供暖器<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/heaters/">https://leetcode.cn/problems/heaters/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</span><br><span class="line">在加热器的加热半径范围内的每个房屋都可以获得供暖。</span><br><span class="line">现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置</span><br><span class="line">请你找出并返回可以覆盖所有房屋的最小加热半径。</span><br><span class="line">说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</span><br></pre></td></tr></table></figure>
<p>也是先排序，然后两个数组分别放置指针指向开头。<br>然后往后匹配，每个房屋都尽可能的匹配能遇到的最往右的最短距离取暖器，并在其中记录最远距离。</p>
<h4 id="题目7-1"><a href="#题目7-1" class="headerlink" title="题目7"></a>题目7</h4><p>缺失的第一个正数<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span><br><span class="line">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span><br><span class="line">玩概念了！</span><br></pre></td></tr></table></figure>
<p>我们把整个区间分为<br>(整理区) l (待定区) r (垃圾区)<br>l的左边，都是做到i位置上放着i+1的区域<br>永远盯着l位置的数字看，看能不能扩充(l++)<br>最好的状况下，认为1~r是可以收集全的，每个数字收集1个，不能有垃圾<br>有垃圾呢？预期就会变差(r–)<br>在所有元素都被整理完毕之后（垃圾去往垃圾区，期望元素进入整理区）<br>答案自然就出现了。</p>
<h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>二分答案法<br>1）估计 最终答案可能的范围 是什么，可以定的粗略，反正二分不了几次<br>2）分析 问题的答案 和 给定条件 之间的 单调性，大部分时候只需要用到 自然智慧<br>3）建立一个check函数，当答案固定的情况下，判断 给定的条件是否达标<br>4）在 最终答案可能的范围上不断二分搜索，每次用check函数判断，直到二分结束，找到最合适的答案<br>核心点：分析单调性、建立check函数<br>为什么要这样做？很多时候我们面对的问题没有一个确切的目标不好求，<br>但是如果我们有了一个确切目标，例如例题一中我们假设能够达到速度k，<br>你会发现我们就很好去设计代码验证答案。</p>
<blockquote>
<p>这个技巧常用且重要，一定要引起重视，非常的美、精妙！</p>
</blockquote>
<h3 id="例题分析：-8"><a href="#例题分析：-8" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-4"><a href="#题目1-4" class="headerlink" title="题目1"></a>题目1</h4><p>爱吃香蕉的珂珂<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉</span><br><span class="line">警卫已经离开了，将在 h 小时后回来。</span><br><span class="line">珂珂可以决定她吃香蕉的速度 k （单位：根/小时)</span><br><span class="line">每个小时，她将会选择一堆香蕉，从中吃掉 k 根</span><br><span class="line">如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉</span><br><span class="line">珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</span><br><span class="line">返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）</span><br></pre></td></tr></table></figure>
<p>经典二分答案<br>(…不能满足…)…ans…(…能满足…)</p>
<h4 id="题目2-4"><a href="#题目2-4" class="headerlink" title="题目2"></a>题目2</h4><p>分割数组的最大值(画匠问题)<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-largest-sum/">https://leetcode.cn/problems/split-array-largest-sum/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组 nums 和一个整数 m</span><br><span class="line">你需要将这个数组分成 m 个非空的连续子数组。</span><br><span class="line">设计一个算法使得这 m 个子数组各自和的最大值最小。</span><br></pre></td></tr></table></figure>
<p>一样的，只是check函数的设计需要巧妙设计。<br><code>if (check(nums, mid) &lt;= k)</code>作为核心点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> part = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num &gt; limit) &#123;</span><br><span class="line">			<span class="keyword">return</span> INT_MAX;<span class="string">&quot;如果num都比limit大那就没有讨论的必要了。&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum + num  &gt; limit) &#123;</span><br><span class="line">			part++;</span><br><span class="line">			sum = num;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sum += num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目3-4"><a href="#题目3-4" class="headerlink" title="题目3"></a>题目3</h4><p>机器人跳跃问题<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71">https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">机器人正在玩一个古老的基于DOS的游戏，游戏中有N+1座建筑，从0到N编号，从左到右排列</span><br><span class="line">编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位</span><br><span class="line">起初， 机器人在编号为0的建筑处</span><br><span class="line">每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E</span><br><span class="line">下一步它将跳到第个k+1建筑</span><br><span class="line">它将会得到或者失去正比于与H(k+1)与E之差的能量</span><br><span class="line">如果 H(k+1) &gt; E 那么机器人就失去H(k+1)-E的能量值</span><br><span class="line">否则它将得到E-H(k+1)的能量值</span><br><span class="line">游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位</span><br><span class="line">现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;buildings, <span class="type">long</span> <span class="type">long</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = *<span class="built_in">max_element</span>(buildings.<span class="built_in">begin</span>(), buildings.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> building : buildings) &#123;</span><br><span class="line">        e -= building - e;</span><br><span class="line">        <span class="keyword">if</span> (e &gt;= max) <span class="keyword">break</span>;<span class="string">&quot;有坑，tmd如果不提前退出long long都能给你爆了&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (e &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目4-3"><a href="#题目4-3" class="headerlink" title="题目4"></a>题目4</h4><p>找出第K小的数对距离<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/">https://leetcode.cn/problems/find-k-th-smallest-pair-distance/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</span><br><span class="line">给你一个整数数组 nums 和一个整数 k</span><br><span class="line">数对由 nums[i] 和 nums[j] 组成且满足 0 &lt;= i &lt; j &lt; nums.length</span><br><span class="line">返回 所有数对距离中 第 k 小的数对距离。</span><br></pre></td></tr></table></figure>
<p><code>if (check(nums, mid) &gt;= k)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> distace)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>(); l++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (r + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[r + <span class="number">1</span>] - nums[l] &lt;= distace) &#123;</span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += r - l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目5-3"><a href="#题目5-3" class="headerlink" title="题目5"></a>题目5</h4><p>同时运行N台电脑的最长时间<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-running-time-of-n-computers/">https://leetcode.cn/problems/maximum-running-time-of-n-computers/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries</span><br><span class="line">其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟</span><br><span class="line">你想使用这些电池让 全部 n 台电脑 同时 运行。</span><br><span class="line">一开始，你可以给每台电脑连接 至多一个电池</span><br><span class="line">然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，</span><br><span class="line">并连接另一个电池，你可以进行这个操作 任意次</span><br><span class="line">新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池</span><br><span class="line">断开连接和连接新的电池不会花费任何时间。注意，你不能给电池充电。</span><br><span class="line">请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</span><br><span class="line">开始玩概念了：“碎片拼接”！很秒！难想！</span><br></pre></td></tr></table></figure>
<p>难点在于考虑到碎片电池的使用策略，实际上也就是贪心算法的范畴了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;batteries, <span class="type">long</span> <span class="type">long</span> limit, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> fullUse = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;battery : batteries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (battery &gt;= limit) &#123;</span><br><span class="line">                fullUse++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += battery;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= (n - fullUse) * limit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目6-2"><a href="#题目6-2" class="headerlink" title="题目6"></a>题目6</h4><p>计算等位时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr长度为n，表示n个服务员，每服务一个客人的时间</span><br><span class="line">给定一个正数m，表示有m个人等位，如果你是刚来的人，每个客人都遵循有空位就上的原则</span><br><span class="line">请问你需要等多久？</span><br><span class="line">假设m远远大于n，比如n &lt;= 10^3, m &lt;= 10^9，该怎么做是最优解？</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谷歌的面试，这个题连考了2个月</p>
</blockquote>
<p>check函数检验当来到时刻n时，服务员们能给多少位人 <strong>开始</strong> 服务。</p>
<h4 id="题目7-2"><a href="#题目7-2" class="headerlink" title="题目7"></a>题目7</h4><p>刀砍毒杀怪兽问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">怪兽的初始血量是一个整数hp，给出每一回合刀砍和毒杀的数值cuts和poisons</span><br><span class="line">第i回合如果用刀砍，怪兽在这回合会直接损失cuts[i]的血，不再有后续效果</span><br><span class="line">第i回合如果用毒杀，怪兽在这回合不会损失血量，但是之后每回合都损失poisons[i]的血量</span><br><span class="line">并且你选择的所有毒杀效果，在之后的回合会叠加</span><br><span class="line">两个数组cuts、poisons，长度都是n，代表你一共可以进行n回合</span><br><span class="line">每一回合你只能选择刀砍或者毒杀中的一个动作</span><br><span class="line">如果你在n个回合内没有直接杀死怪兽，意味着你已经无法有新的行动了</span><br><span class="line">但是怪兽如果有中毒效果的话，那么怪兽依然会不停扣血，直到血量耗尽的那回合死掉</span><br><span class="line">返回至少多少回合怪兽会死掉</span><br><span class="line">数据范围 : 1&lt;=n&lt;=10^5；1&lt;=hp&lt;=10^9；1&lt;=cuts[i]、poisons[i]&lt;=10^9</span><br></pre></td></tr></table></figure>
<blockquote>
<p>真实大厂算法笔试题</p>
</blockquote>
<p>check检验来到n回合时能否斩杀怪物，当然以贪心思维去设计检验机制。</p>
<h2 id="单调栈、单调队列"><a href="#单调栈、单调队列" class="headerlink" title="单调栈、单调队列"></a>单调栈、单调队列</h2><p>单调栈、单调队列都是以维护结构单调性的方式，保存答案的可能性。</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈最经典的用法是解决如下问题：<br>每个位置都求：<br>0）当前位置的 左侧比当前位置的数字小，且距离最近的位置 在哪<br>1）当前位置的 右侧比当前位置的数字小，且距离最近的位置 在哪<br>或者<br>每个位置都求：<br>0）当前位置的 左侧比当前位置的数字大，且距离最近的位置 在哪<br>1）当前位置的 右侧比当前位置的数字大，且距离最近的位置 在哪</p>
<p>用单调栈的方式可以做到：求解过程中，单调栈所有调整的总代价为O(n)，单次操作的均摊代价为O(1)</p>
<p>除了单调栈最经典的用法之外，在很多问题里单调栈还可以 维持求解答案的可能性<br>1）单调栈里的所有对象按照 规定好的单调性来组织<br>2）当某个对象进入单调栈时，<br>   会从 栈顶开始 依次淘汰单调栈里 对后续求解答案没有帮助 的对象<br>3）每个对象从栈顶弹出的时 结算当前对象参与的答案，随后这个对象 不再参与后续求解答案的过程<br>4）其实是 先有对题目的分析！进而发现单调性，然后利用 单调栈的特征 去实现</p>
<h3 id="例题分析：-9"><a href="#例题分析：-9" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-5"><a href="#题目1-5" class="headerlink" title="题目1"></a>题目1</h4><p>单调栈最经典用法的模版<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb">https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb</a></p>
<h4 id="题目2-5"><a href="#题目2-5" class="headerlink" title="题目2"></a>题目2</h4><p>每日温度<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer</span><br><span class="line">其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后</span><br><span class="line">如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br></pre></td></tr></table></figure>

<p>经典到不能再经典的单调栈标准题目。</p>
<h4 id="题目3-5"><a href="#题目3-5" class="headerlink" title="题目3"></a>题目3</h4><p>子数组的最小值之和<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-subarray-minimums/">https://leetcode.cn/problems/sum-of-subarray-minimums/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。</span><br><span class="line">由于答案可能很大，因此 返回答案模 10^9 + 7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这道题答案很大，要求取模</p>
</blockquote>
<p>很好理解，维持大压小，来到破坏单调性的位置意味着收获答案，然后逐层收集即可。</p>
<h4 id="题目4-4"><a href="#题目4-4" class="headerlink" title="题目4"></a>题目4</h4><p>柱状图中最大的矩形<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram">https://leetcode.cn/problems/largest-rectangle-in-histogram</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数，用来表示柱状图中各个柱子的高度</span><br><span class="line">每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积</span><br></pre></td></tr></table></figure>

<p>对于 <strong>i号柱子</strong> 他能往左右伸展的最大距离取决于他左右能碰到的第一个小于他的 <strong>柱子</strong>，<br>这一点就是破题关键。</p>
<h4 id="题目5-4"><a href="#题目5-4" class="headerlink" title="题目5"></a>题目5</h4><p>最大矩形<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/">https://leetcode.cn/problems/maximal-rectangle/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个仅包含 0 和 1 、大小为 rows * cols 的二维二进制矩阵</span><br><span class="line">找出只包含 1 的最大矩形，并返回其面积</span><br></pre></td></tr></table></figure>

<p>利用 <strong>压缩矩阵</strong> 的技巧，转化为.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">lc.84. 柱状图中最大的矩形</a>问题</p>
<h4 id="题目6-3"><a href="#题目6-3" class="headerlink" title="题目6"></a>题目6</h4><p>最大宽度坡<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-ramp/">https://leetcode.cn/problems/maximum-width-ramp/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;= A[j]</span><br><span class="line">这样的坡的宽度为 j - i，找出 A 中的坡的最大宽度，如果不存在，返回 0</span><br></pre></td></tr></table></figure>

<p><del>难点在于怎么想到用单调栈</del><br>本质上还是维护答案的候选者，淘汰不可能成为答案的候选。<br>在此基础上寻找尽可能长的坡</p>
<h4 id="题目7-3"><a href="#题目7-3" class="headerlink" title="题目7"></a>题目7</h4><p>去除重复字母保证剩余字符串的字典序最小<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">https://leetcode.cn/problems/remove-duplicate-letters/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次</span><br><span class="line">需保证 返回结果的字典序最小</span><br><span class="line">要求不能打乱其他字符的相对位置</span><br></pre></td></tr></table></figure>

<p>额外维护一个词频表和一个入栈表。</p>
<ol>
<li>根据词频表和入栈表已经题目要求决定当前栈顶字母是否能被弹出，能被弹出的字母应当是后续仍然可以遍历到的，且字典序大于当前待入栈字母字典序的。</li>
<li>如果一个字母已经入栈，那么就不能再入栈了。</li>
</ol>
<h4 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h4><p>大鱼吃小鱼问题<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de">https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，每个值代表鱼的体重</span><br><span class="line">每一轮，每条鱼都会吃掉右边离自己最近比自己体重小的鱼，每条鱼向右找只吃一条</span><br><span class="line">但是吃鱼这件事是同时发生的，也就是同一轮在A吃掉B的同时，A也可能被别的鱼吃掉</span><br><span class="line">如果有多条鱼在当前轮找到的是同一条小鱼，那么在这一轮，这条小鱼同时被这些大鱼吃</span><br><span class="line">请问多少轮后，鱼的数量就固定了</span><br><span class="line">比如 : 8 3 1 5 6 7 2 4</span><br><span class="line">第一轮 : 8吃3；3吃1；5、6、7吃2；4没有被吃。数组剩下 8 5 6 7 4</span><br><span class="line">第二轮 : 8吃5；5、6、7吃4。数组剩下 8 6 7</span><br><span class="line">第三轮 : 8吃6。数组剩下 8 7</span><br><span class="line">第四轮 : 8吃7。数组剩下 8</span><br><span class="line">过程结束，返回4</span><br></pre></td></tr></table></figure>

<p>依然是维护答案的可能性。<br>从右往左看，维护一个信息，当这个鱼被吃时，至少需要过了多少回合，后面吃掉他的鱼继承他的回合数。</p>
<h4 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h4><p>统计全1子矩形的数量<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-submatrices-with-all-ones/">https://leetcode.cn/problems/count-submatrices-with-all-ones/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个 m * n 的矩阵 mat，其中只有0和1两种值</span><br><span class="line">请你返回有多少个 子矩形 的元素全部都是1</span><br></pre></td></tr></table></figure>

<p>两个技巧：<strong>1. 矩阵压缩</strong>、<strong>2. 从上往下滚动计算</strong>&#x3D;&#x3D;即我们来到i行时，只关注以i行为底边的矩形</p>
<p>然后问题就又转化为.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">lc.84. 柱状图中最大的矩形</a>问题</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>单调队列最经典的用法是解决如下问题：<br>滑动窗口在滑动时，r++代表右侧数字进窗口，l++代表左侧数字出窗口<br>这个过程中，想随时得到当前滑动窗口的 最大值 或者 最小值<br>窗口滑动的过程中，单调队列所有调整的总代价为O(n)，单次操作的均摊代价为O(1)</p>
<p>除了单调队列最经典的用法之外，在很多问题里单调队列还可以 维持求解答案的可能性<br>1）单调队列里的所有对象按照 规定好的单调性来组织<br>2）当某个对象从队尾进入单调队列时，<br>   会从 队头 或者 队尾 依次淘汰单调队列里，对后续求解答案没有帮助 的对象<br>3）每个对象一旦从单调队列弹出，可以结算此时这个对象参与的答案，<br>   随后这个对象 不再参与后续求解答案的过程<br>4）其实是 先有对题目的分析！进而发现单调性，然后利用 单调队列的特征 去实现</p>
<h3 id="例题分析：-10"><a href="#例题分析：-10" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-6"><a href="#题目1-6" class="headerlink" title="题目1"></a>题目1</h4><p>滑动窗口最大值（单调队列经典用法模版）<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧</span><br><span class="line">你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回 滑动窗口中的最大值 。</span><br></pre></td></tr></table></figure>

<h4 id="题目2-6"><a href="#题目2-6" class="headerlink" title="题目2"></a>题目2</h4><p>绝对差不超过限制的最长连续子数组<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，和一个表示限制的整数 limit</span><br><span class="line">请你返回最长连续子数组的长度</span><br><span class="line">该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit</span><br><span class="line">如果不存在满足条件的子数组，则返回 0</span><br></pre></td></tr></table></figure>

<h4 id="题目3-6"><a href="#题目3-6" class="headerlink" title="题目3"></a>题目3</h4><p>接取落水的最小花盆<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2698">https://www.luogu.com.cn/problem/P2698</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">老板需要你帮忙浇花。给出 N 滴水的坐标，y 表示水滴的高度，x 表示它下落到 x 轴的位置</span><br><span class="line">每滴水以每秒1个单位长度的速度下落。你需要把花盆放在 x 轴上的某个位置</span><br><span class="line">使得从被花盆接着的第 1 滴水开始，到被花盆接着的最后 1 滴水结束，之间的时间差至少为 D</span><br><span class="line">我们认为，只要水滴落到 x 轴上，与花盆的边沿对齐，就认为被接住</span><br><span class="line">给出 N 滴水的坐标和 D 的大小，请算出最小的花盆的宽度 W</span><br></pre></td></tr></table></figure>

<p>先排个序。<br>感觉很像滑窗）</p>
<h4 id="题目4-5"><a href="#题目4-5" class="headerlink" title="题目4"></a>题目4</h4><p>和至少为K的最短子数组<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，其中的值有可能正、负、0</span><br><span class="line">给定一个正数k</span><br><span class="line">返回累加和&gt;=k的所有子数组中，最短的子数组长度</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：本题用到构建前缀和的技巧</p>
</blockquote>
<p>要点在于构建了前缀和之后可以很方便的查询区间和。</p>
<h4 id="题目5-5"><a href="#题目5-5" class="headerlink" title="题目5"></a>题目5</h4><p>满足不等式的最大值<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-value-of-equation/">https://leetcode.cn/problems/max-value-of-equation/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 points 和一个整数 k</span><br><span class="line">数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序</span><br><span class="line">也就是说 points[i] = [xi, yi]</span><br><span class="line">并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下，xi &lt; xj 总成立</span><br><span class="line">请你找出 yi + yj + |xi - xj| 的 最大值，</span><br><span class="line">其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length</span><br><span class="line">题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。</span><br></pre></td></tr></table></figure>

<p>要点在于分析题目，将限制条件拆成(Yl - Xl) + (Yr  + Xr)&#x3D;&#x3D;即左端点的YX差加上右端点的YX和。</p>
<h4 id="题目6-4"><a href="#题目6-4" class="headerlink" title="题目6"></a>题目6</h4><p>你可以安排的最多任务数目<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/">https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成</span><br><span class="line">需要的力量值保存在下标从 0 开始的整数数组 tasks 中，</span><br><span class="line">第i个任务需要 tasks[i] 的力量才能完成</span><br><span class="line">每个工人的力量值保存在下标从 0 开始的整数数组workers中，</span><br><span class="line">第j个工人的力量值为 workers[j]</span><br><span class="line">每个工人只能完成一个任务，且力量值需要大于等于该任务的力量要求值，即workers[j]&gt;=tasks[i]</span><br><span class="line">除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength</span><br><span class="line">你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸</span><br><span class="line">给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength</span><br><span class="line">请你返回 最多 有多少个任务可以被完成。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：本题大思路用到二分答案法</p>
</blockquote>
<p>大思路是二分答案，而check函数的实现则同时利用了贪心思路和单调队列（好像只用到了队列性质。。。）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> tl, <span class="type">int</span> tr, <span class="type">int</span> wl, <span class="type">int</span> wr, <span class="type">int</span> s, <span class="type">int</span> pills)</span> </span>&#123;</span><br><span class="line">	h = t = <span class="number">0</span>;  <span class="comment">// 重置双端队列</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 已经使用药丸的数量</span></span><br><span class="line">	<span class="comment">// i: 工人下标，j: 任务下标</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = wl, j = tl; i &lt;= wr; i++) &#123;</span><br><span class="line">		<span class="comment">// 不吃药情况下，工人 workers[i] 能够完成的任务</span></span><br><span class="line">		<span class="keyword">for</span> (; j &lt;= tr &amp;&amp; tasks[j] &lt;= workers[i]; j++) &#123;</span><br><span class="line">			dequeArr[t++] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (h &lt; t &amp;&amp; tasks[dequeArr[h]] &lt;= workers[i]) &#123;</span><br><span class="line">			<span class="comment">// 当前工人无需吃药即可完成任务，分配队列头部任务</span></span><br><span class="line">			h++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 允许使用药丸，尝试扩展任务区间</span></span><br><span class="line">			<span class="keyword">for</span> (; j &lt;= tr &amp;&amp; tasks[j] &lt;= workers[i] + s; j++) &#123;</span><br><span class="line">				dequeArr[t++] = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (h &lt; t) &#123;</span><br><span class="line">				<span class="comment">// 分配该任务，但需要使用药丸</span></span><br><span class="line">				cnt++;</span><br><span class="line">				t--;  <span class="comment">// 这里选择队尾任务（难度更高的任务）</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt &lt;= pills;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集的使用是如下的场景<br>1）一开始每个元素都拥有自己的集合，在自己的集合里只有这个元素自己<br>2）find(i)：查找i所在集合的代表元素，代表元素来代表i所在的集合<br>3）boolean isSameSet(a, b)：判断a和b在不在一个集合里<br>4）void union(a, b)：a所在集合所有元素 与 b所在集合所有元素 合并成一个集合<br>5）各种操作单次调用的均摊时间复杂度为O(1)<br>并查集的小扩展<br>可以定制信息：并查集目前有多少个集合，以及给每个集合打上标签信息</p>
<h3 id="神奇优化：为什么并查集是O-1-的操作？"><a href="#神奇优化：为什么并查集是O-1-的操作？" class="headerlink" title="神奇优化：为什么并查集是O(1)的操作？"></a>神奇优化：为什么并查集是O(1)的操作？</h3><p>并查集的两个优化，都发生在find方法里<br>1）扁平化（路径压缩）（一定要做）<br>2）小挂大（可以不做，原论文中是秩的概念，可以理解为 粗略高度 或者 大小）</p>
<p>并查集时间复杂度的理解<br>作为如此简单、小巧的结构，<br>感性理解单次调用的均摊时间复杂度为O(1)即可，其实为α(n)，反阿克曼函数。<br>当n&#x3D;10^80次方即可探明宇宙原子量，α(n)的返回值也不超过6，那就可以认为是O(1)<br>并查集的发明者Bernard A. Galler和Michael J. Fischer，<br>从1964年证明到1989年才证明完毕。</p>
<h3 id="例题分析：-11"><a href="#例题分析：-11" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-7"><a href="#题目1-7" class="headerlink" title="题目1"></a>题目1</h4><p>并查集模版(牛客)<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372">https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372</a></p>
<p>路径压缩 + 小挂大</p>
<h4 id="题目2-7"><a href="#题目2-7" class="headerlink" title="题目2"></a>题目2</h4><p>并查集模版(洛谷)<br>测试链接 : <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">https://www.luogu.com.cn/problem/P3367</a></p>
<p>用递归函数实现路径压缩<br>一般情况下小挂大的优化可以省略的写法</p>
<h4 id="题目3-7"><a href="#题目3-7" class="headerlink" title="题目3"></a>题目3</h4><p>情侣牵手<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/couples-holding-hands/">https://leetcode.cn/problems/couples-holding-hands/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手</span><br><span class="line">人和座位由一个整数数组 row，表示其中 row[i] 是坐在第 i 个座位上的人的ID</span><br><span class="line">情侣们按顺序编号，第0对是 (0, 1)，第1对是 (2, 3)，以此类推</span><br><span class="line">返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起</span><br><span class="line">每次交换可选择任意两人，让他们站起来交换座位</span><br></pre></td></tr></table></figure>

<p>将所有情侣对（先不管配不配对）视为单元素集合。<br>然后合并所有未配对集合。</p>
<h4 id="题目4-6"><a href="#题目4-6" class="headerlink" title="题目4"></a>题目4</h4><p>相似字符串组<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/similar-string-groups/">https://leetcode.cn/problems/similar-string-groups/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等</span><br><span class="line">那么称 X 和 Y 两个字符串相似</span><br><span class="line">如果这两个字符串本身是相等的，那它们也是相似的</span><br><span class="line">例如，&quot;tars&quot; 和 &quot;rats&quot; 是相似的 (交换 0 与 2 的位置)；</span><br><span class="line">&quot;rats&quot; 和 &quot;arts&quot; 也是相似的，但是 &quot;star&quot; 不与 &quot;tars&quot;，&quot;rats&quot;，或 &quot;arts&quot; 相似</span><br><span class="line">总之，它们通过相似性形成了两个关联组：&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; 和 &#123;&quot;star&quot;&#125;</span><br><span class="line">注意，&quot;tars&quot; 和 &quot;arts&quot; 是在同一组中，即使它们并不相似</span><br><span class="line">形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</span><br><span class="line">给你一个字符串列表 strs列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。</span><br><span class="line">返回 strs 中有多少字符串组</span><br></pre></td></tr></table></figure>

<p>开始时每个字符串都是单元素集合，然后根据相似关系例如：<br>{str1-&gt;str2-&gt;str3}，<br>以此构建关联集合。</p>
<h4 id="题目5-6"><a href="#题目5-6" class="headerlink" title="题目5"></a>题目5</h4><p>岛屿数量<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量</span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成</span><br><span class="line">此外，你可以假设该网格的四条边均被水包围</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：本题还可以用洪水填充算法求解</p>
</blockquote>
<p>没啥好说的，将所有相邻的1合并为一个集合就行，最后统计剩下的集合数就好。</p>
<h4 id="题目6-5"><a href="#题目6-5" class="headerlink" title="题目6"></a>题目6</h4><p>移除最多的同行或同列石头<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/">https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头</span><br><span class="line">如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头</span><br><span class="line">给你一个长度为 n 的数组 stones ，</span><br><span class="line">其中 stones[i] = [xi, yi] 表示第 i 块石头的位置</span><br><span class="line">返回 可以移除的石子 的最大数量。</span><br></pre></td></tr></table></figure>

<p>我们需要统计来到 <strong>(i , j)</strong> 位置时，当前位置是否已经有了石头？有则合并 。<br>所以额外维护一个行列石头最早出现表就行</p>
<h4 id="题目7-4"><a href="#题目7-4" class="headerlink" title="题目7"></a>题目7</h4><p>找出知晓秘密的所有专家<br>链接测试 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-people-with-secret/">https://leetcode.cn/problems/find-all-people-with-secret/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号</span><br><span class="line">另外给你一个下标从 0 开始的二维整数数组 meetings</span><br><span class="line">其中 meetings[i] = [xi, yi, timei]，表示专家 xi 和专家 yi 在时间 timei 要开一场会</span><br><span class="line">一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson</span><br><span class="line">专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson</span><br><span class="line">接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播</span><br><span class="line">更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密</span><br><span class="line">那么他将会与专家 yi 分享这个秘密，反之亦然。秘密共享是 瞬时发生 的</span><br><span class="line">也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享</span><br><span class="line">在所有会议都结束之后，返回所有知晓这个秘密的专家列表，你可以按 任何顺序 返回答案</span><br></pre></td></tr></table></figure>

<p>先给会议序列按照来到时刻排序，然后合并同时刻的集合，标记被传染的集合，未被传染的集合拆分回原样。</p>
<h4 id="题目8-1"><a href="#题目8-1" class="headerlink" title="题目8"></a>题目8</h4><p>好路径的数目<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-good-paths/">https://leetcode.cn/problems/number-of-good-paths/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一棵 n 个节点的树（连通无向无环的图）</span><br><span class="line">节点编号从0到n-1，且恰好有n-1条边</span><br><span class="line">给你一个长度为 n 下标从 0 开始的整数数组 vals</span><br><span class="line">分别表示每个节点的值。同时给你一个二维整数数组 edges</span><br><span class="line">其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边</span><br><span class="line">好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值</span><br><span class="line">请你返回不同好路径的数目</span><br><span class="line">注意，一条路径和它反向的路径算作 同一 路径</span><br><span class="line">比方说， 0 -&gt; 1 与 1 -&gt; 0 视为同一条路径。单个节点也视为一条合法路径</span><br></pre></td></tr></table></figure>

<p>关键在于边处理顺序：<br>将待处理边按照关联点权值的max按从小大大排序，<br>然后合并同权集合时结算答案，不同权集合则不结算。<br>这样的顺序可以保证我们再处理到类似 {max: 1} ~ {max: 2} ~ {max: 1}时，不会重复计算。</p>
<h4 id="题目9-1"><a href="#题目9-1" class="headerlink" title="题目9"></a>题目9</h4><p>尽量减少恶意软件的传播 II<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-malware-spread-ii/">https://leetcode.cn/problems/minimize-malware-spread-ii/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个由 n 个节点组成的网络，一定是无向图，用 n * n 个邻接矩阵 graph 表示</span><br><span class="line">在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。</span><br><span class="line">一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，</span><br><span class="line">且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。</span><br><span class="line">这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</span><br><span class="line">假设 M(initial) 是在恶意软件停止传播之后，</span><br><span class="line">整个网络中感染恶意软件的最终节点数。</span><br><span class="line">我们可以从 initial 中删除一个节点，</span><br><span class="line">并完全移除该节点以及从该节点到任何其他节点的任何连接。</span><br><span class="line">请返回移除后能够使 M(initial) 最小化的节点。</span><br><span class="line">如果有多个节点满足条件，返回索引 最小的节点 。initial 中每个整数都不同</span><br></pre></td></tr></table></figure>

<p>先合并所有正常点。<br>然后根据正常集合链接的传染源判断答案。</p>
<h2 id="洪水填充"><a href="#洪水填充" class="headerlink" title="洪水填充"></a>洪水填充</h2><p>洪水填充是一种很简单的技巧，设置路径信息进行剪枝和统计，类似感染的过程<br>路径信息不撤销，来保证每一片的感染过程可以得到区分<br>看似是暴力递归过程，其实时间复杂度非常好，遍历次数和样本数量的规模一致</p>
<h3 id="例题分析：-12"><a href="#例题分析：-12" class="headerlink" title="例题分析："></a>例题分析：</h3><h4 id="题目1-8"><a href="#题目1-8" class="headerlink" title="题目1"></a>题目1</h4><p>岛屿数量<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量</span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成</span><br><span class="line">此外，你可以假设该网格的四条边均被水包围</span><br></pre></td></tr></table></figure>

<p>没啥好说的，标准靶场）<br>就是遇到 <strong>‘1’</strong> 就洪水填充为 ‘0’， 然后计数。</p>
<h4 id="题目2-8"><a href="#题目2-8" class="headerlink" title="题目2"></a>题目2</h4><p>被围绕的区域<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个 m x n 的矩阵 board ，由若干字符 &#x27;X&#x27; 和 &#x27;O&#x27; ，找到所有被 &#x27;X&#x27; 围绕的区域</span><br><span class="line">并将这些区域里所有的 &#x27;O&#x27; 用 &#x27;X&#x27; 填充。</span><br></pre></td></tr></table></figure>

<p><del>我tm的把O看成0了。</del><br>一样的，先把边界处的O洪水填充标注为F<br>然后遍历将 O 改 X， F 改 O 就行。</p>
<h4 id="题目3-8"><a href="#题目3-8" class="headerlink" title="题目3"></a>题目3</h4><p>最大人工岛<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/making-a-large-island/">https://leetcode.cn/problems/making-a-large-island/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个大小为 n * n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</span><br><span class="line">返回执行此操作后，grid 中最大的岛屿面积是多少？</span><br><span class="line">岛屿 由一组上、下、左、右四个方向相连的 1 形成</span><br></pre></td></tr></table></figure>

<p>只是比前面的题目多了要求，你需要额外计算洪水填充填了多少格子，可以放在洪水填充中计算，也可以后面遍历一遍统计。</p>
<h4 id="题目4-7"><a href="#题目4-7" class="headerlink" title="题目4"></a>题目4</h4><p>打砖块<br>测试链接 : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bricks-falling-when-hit/">https://leetcode.cn/problems/bricks-falling-when-hit/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有一个 m * n 的二元网格 grid ，其中 1 表示砖块，0 表示空白</span><br><span class="line">砖块 稳定（不会掉落）的前提是：</span><br><span class="line">一块砖直接连接到网格的顶部，或者</span><br><span class="line">至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时</span><br><span class="line">给你一个数组 hits ，这是需要依次消除砖块的位置</span><br><span class="line">每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失</span><br><span class="line">然后其他的砖块可能因为这一消除操作而 掉落</span><br><span class="line">一旦砖块掉落，它会 立即 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）</span><br><span class="line">返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。</span><br><span class="line">注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</span><br></pre></td></tr></table></figure>

<p>这道题的精髓在于 <strong>时间回溯</strong>。<br>从 后 往 前 逆向分析，然后配合洪水填充标记砖块。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.l4place.icu">l4place</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/">http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">除特別声明外，本博客所有文章均遵守 WTFPL 许可。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8/">入门</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/20/GitHub%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E8%B5%B7%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAPR/" title="GitHub最佳实践之发起你的第一个PR"><img class="cover" src="/img/default_post_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">GitHub最佳实践之发起你的第一个PR</div></div><div class="info-2"><div class="info-item-1">你可以把 Git 比作是一本笔记本，而 GitHub 就像是一个云笔记平台（比如Evernote），它让你可以随时随地访问、分享和协作管理你的笔记（代码）。</div></div></div></a><a class="pagination-related" href="/2025/02/10/GitHub%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E8%B5%B7%E7%AC%AC%E4%B8%80%E4%B8%AAPR/" title="GitHub最佳实践之发起第一个PR"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-10</div><div class="info-item-2">GitHub最佳实践之发起第一个PR</div></div><div class="info-2"><div class="info-item-1">你可以把 Git 比作是一本笔记本，而 GitHub 就像是一个云笔记平台（比如Evernote），它让你可以随时随地访问、分享和协作管理你的笔记（代码）。</div></div></div></a><a class="pagination-related" href="/2025/01/01/HELLOL4PLACE/" title="”Hello world！“"><img class="cover" src="https://blog-1328888607.cos.ap-guangzhou.myqcloud.com/assets/img/20250125002731742.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-01</div><div class="info-item-2">”Hello world！“</div></div><div class="info-2"><div class="info-item-1">基于hexo框架的个人博客，以及其上二次开发的butterfly主题</div></div></div></a><a class="pagination-related" href="/2025/04/06/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W03/" title="学习周报W03"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-06</div><div class="info-item-2">学习周报W03</div></div><div class="info-2"><div class="info-item-1">因为只是学完了图论，但是DP还没学完，所以这周就先总结图论吧，DP留到下周在讲。</div></div></div></a><a class="pagination-related" href="/2025/04/20/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W05/" title="学习周报W05"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">学习周报W05</div></div><div class="info-2"><div class="info-item-1">我需要实践，更多的实践，更好的实践。</div></div></div></a><a class="pagination-related" href="/2025/04/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W04/" title="学习周报W04"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">学习周报W04</div></div><div class="info-2"><div class="info-item-1">无论怎么说，都是对所有状态的穷举。而如何找出，定义这些状态，是我们所要做的，这就是 动态规划。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqusjs-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">L4plAce</div><div class="author-info-description">以空想为罗盘，以实践作航船</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/L4plAcEee"><i class="fab fa-github"></i><span>View in Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果图片碎了那就证明你需要挂梯子了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E3%80%81%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">最大公约数、同余定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%9F-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">怎么求最大公约数和最小公倍数？- 辗转相除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">代码实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">例题分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">同余定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E5%99%A8%E4%B8%8E%E6%9A%B4%E5%8A%9B%E6%89%93%E8%A1%A8%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">对数器与暴力打表找规律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">3.1.</span> <span class="toc-text">例题分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">根据数据量猜解法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-2"><span class="toc-number">4.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-%E6%9C%80%E4%BC%98%E7%9A%84%E6%8A%80%E8%83%BD%E9%87%8A%E6%94%BE%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">题目1 : 最优的技能释放顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2%EF%BC%9A%E8%B6%85%E7%BA%A7%E5%9B%9E%E6%96%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">4.1.2.</span> <span class="toc-text">题目2：超级回文数的数目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-3"><span class="toc-number">5.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-%E6%8E%A5%E5%A4%B4%E5%AF%86%E5%8C%99"><span class="toc-number">5.1.1.</span> <span class="toc-text">题目1 接头密匙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC"><span class="toc-number">5.1.2.</span> <span class="toc-text">题目2 数组中两个数的最大异或值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-%E5%9C%A8%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">5.1.3.</span> <span class="toc-text">题目3 在二维字符数组中搜索可能的单词</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86"><span class="toc-number">6.</span> <span class="toc-text">前缀和、差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">6.1.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8A%80%E5%B7%A7-%E8%A7%A3%E5%86%B3%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">例题分析：构建前缀信息的技巧-解决子数组相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">差分数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-4"><span class="toc-number">6.4.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1"><span class="toc-number">6.4.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2"><span class="toc-number">6.4.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3"><span class="toc-number">6.4.3.</span> <span class="toc-text">题目3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">6.5.</span> <span class="toc-text">二维前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">6.6.</span> <span class="toc-text">二维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-5"><span class="toc-number">6.7.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-1"><span class="toc-number">6.7.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-1"><span class="toc-number">6.7.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-1"><span class="toc-number">6.7.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4"><span class="toc-number">6.7.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5"><span class="toc-number">6.7.5.</span> <span class="toc-text">题目5</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-6"><span class="toc-number">7.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-2"><span class="toc-number">7.1.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-2"><span class="toc-number">7.1.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-2"><span class="toc-number">7.1.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-1"><span class="toc-number">7.1.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-1"><span class="toc-number">7.1.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6"><span class="toc-number">7.1.6.</span> <span class="toc-text">题目6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7"><span class="toc-number">7.1.7.</span> <span class="toc-text">题目7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-7"><span class="toc-number">8.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-3"><span class="toc-number">8.1.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-3"><span class="toc-number">8.1.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-3"><span class="toc-number">8.1.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-2"><span class="toc-number">8.1.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-2"><span class="toc-number">8.1.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-1"><span class="toc-number">8.1.6.</span> <span class="toc-text">题目6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7-1"><span class="toc-number">8.1.7.</span> <span class="toc-text">题目7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="toc-number">9.</span> <span class="toc-text">二分答案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-8"><span class="toc-number">9.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-4"><span class="toc-number">9.1.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-4"><span class="toc-number">9.1.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-4"><span class="toc-number">9.1.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-3"><span class="toc-number">9.1.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-3"><span class="toc-number">9.1.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-2"><span class="toc-number">9.1.6.</span> <span class="toc-text">题目6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7-2"><span class="toc-number">9.1.7.</span> <span class="toc-text">题目7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">单调栈、单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">10.1.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-9"><span class="toc-number">10.2.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-5"><span class="toc-number">10.2.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-5"><span class="toc-number">10.2.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-5"><span class="toc-number">10.2.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-4"><span class="toc-number">10.2.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-4"><span class="toc-number">10.2.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-3"><span class="toc-number">10.2.6.</span> <span class="toc-text">题目6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7-3"><span class="toc-number">10.2.7.</span> <span class="toc-text">题目7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE8"><span class="toc-number">10.2.8.</span> <span class="toc-text">题目8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE9"><span class="toc-number">10.2.9.</span> <span class="toc-text">题目9</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">10.3.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-10"><span class="toc-number">10.4.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-6"><span class="toc-number">10.4.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-6"><span class="toc-number">10.4.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-6"><span class="toc-number">10.4.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-5"><span class="toc-number">10.4.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-5"><span class="toc-number">10.4.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-4"><span class="toc-number">10.4.6.</span> <span class="toc-text">题目6</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">11.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%98%AFO-1-%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">神奇优化：为什么并查集是O(1)的操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-11"><span class="toc-number">11.2.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-7"><span class="toc-number">11.2.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-7"><span class="toc-number">11.2.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-7"><span class="toc-number">11.2.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-6"><span class="toc-number">11.2.4.</span> <span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5-6"><span class="toc-number">11.2.5.</span> <span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6-5"><span class="toc-number">11.2.6.</span> <span class="toc-text">题目6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE7-4"><span class="toc-number">11.2.7.</span> <span class="toc-text">题目7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE8-1"><span class="toc-number">11.2.8.</span> <span class="toc-text">题目8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE9-1"><span class="toc-number">11.2.9.</span> <span class="toc-text">题目9</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%AA%E6%B0%B4%E5%A1%AB%E5%85%85"><span class="toc-number">12.</span> <span class="toc-text">洪水填充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90%EF%BC%9A-12"><span class="toc-number">12.1.</span> <span class="toc-text">例题分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-8"><span class="toc-number">12.1.1.</span> <span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-8"><span class="toc-number">12.1.2.</span> <span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-8"><span class="toc-number">12.1.3.</span> <span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-7"><span class="toc-number">12.1.4.</span> <span class="toc-text">题目4</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/20/GitHub%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E8%B5%B7%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAPR/" title="GitHub最佳实践之发起你的第一个PR"><img src="/img/default_post_cover.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GitHub最佳实践之发起你的第一个PR"/></a><div class="content"><a class="title" href="/2025/04/20/GitHub%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E8%B5%B7%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAPR/" title="GitHub最佳实践之发起你的第一个PR">GitHub最佳实践之发起你的第一个PR</a><time datetime="2025-04-20T03:00:07.207Z" title="发表于 2025-04-20 11:00:07">2025-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/20/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W05/" title="学习周报W05">学习周报W05</a><time datetime="2025-04-19T16:00:00.000Z" title="发表于 2025-04-20 00:00:00">2025-04-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/13/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W04/" title="学习周报W04">学习周报W04</a><time datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5W03/" title="学习周报W03">学习周报W03</a><time datetime="2025-04-06T12:48:14.754Z" title="发表于 2025-04-06 20:48:14">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/04/TRY-%E5%86%99%E4%B8%80%E4%BB%BD%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A%E5%BA%95%E7%A8%BF/" title="TRY-写一份实习报告发言稿">TRY-写一份实习报告发言稿</a><time datetime="2025-04-04T05:55:19.883Z" title="发表于 2025-04-04 13:55:19">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: #00bfff;"><div id="footer-wrap"><div class="copyright">&copy;2025 By L4plAce</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">数字，哲学与爱</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'== 'shuoshuo'
  const dqOption = null

  const destroyDisqusjs = () => {
    disqusjs.destroy()
    window.disqusjs = null
  }

  const themeChange = (el, path) => {
    destroyDisqusjs()
    initDisqusjs(el, path)
  }

  const initDisqusjs = (el = document, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyDisqusjs = () => {
        destroyDisqusjs()
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    disqusjs = new DisqusJS({
      shortname: 'l4place',
      title: '学习周报-02-算法',
      apikey: 'x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8',
      ...dqOption,
      identifier: isShuoshuo ? path : (dqOption && dqOption.identifier) || '/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/',
      url: isShuoshuo ? location.origin + path : (dqOption && dqOption.url) || 'http://www.l4place.icu/2025/03/31/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5-02-%E7%AE%97%E6%B3%95/'
    })

    disqusjs.render(el.querySelector('#disqusjs-wrap'))

    btf.addGlobalFn('themeChange', () => themeChange(el, path), 'disqusjs')
  }

  const loadDisqusjs = async(el, path) => {
    if (window.disqusJsLoad) initDisqusjs(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/disqusjs/dist/browser/styles/disqusjs.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/disqusjs/dist/browser/disqusjs.es2015.umd.min.js')
      initDisqusjs(el, path)
      window.disqusJsLoad = true
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqusjs-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=l4place&api_key=x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()
      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if (isShuoshuo) {
    'Disqusjs' === 'Disqusjs'
      ? window.shuoshuoComment = { loadComment: loadDisqusjs }
      : window.loadOtherComment = loadDisqusjs
    return
  }

  if ('Disqusjs' === 'Disqusjs' || !false) {
    if (false) btf.loadComment(document.getElementById('disqusjs-wrap'), loadDisqusjs)
    else {
      loadDisqusjs()
      
    }
  } else {
    window.loadOtherComment = loadDisqusjs
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'disqus-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const getComment = ele => {
    fetch('https://disqus.com/api/3.0/forums/listPosts.json?forum=l4place&related=thread&limit=6&api_key=x13hKI63LwsTKgH9HQ2fBgsQ39NmUMQVj2awrSVw59kE94ALSCkeV5g1XAQZIpK8')
      .then(response => response.json())
      .then(data => {
        const disqusArray = data.response.map(item => {
          return {
            'avatar': item.author.avatar.cache,
            'content': changeContent(item.message),
            'nick': item.author.name,
            'url': item.url,
            'date': item.createdAt
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(disqusArray), 10/(60*24))
        generateHtml(disqusArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }

  run(keyName, getComment)
})</script><script defer src="https://fastly.jsdelivr.net/npm/live2d-widgets@0/autoload.js"></script><div class="aplayer no-destroy" data-id="2226764201" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>